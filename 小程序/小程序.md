## 一.什么是小程序

+ 不需要下载安装既可使用的应用



### 各个平台小程序的时间线

◼ 各个平台小程序大概的发布时间线： 

◼ 2017年1月 微信小程序上线，依附于微信App； 

◼ 2018年7月 百度小程序上线，依附于百度App； 

◼ 2018年9月 支付宝程序线，依附于支付宝App； 

◼ 2018年10月 抖音小程序上线，依附于抖音App； 

◼ 2018年11月 头条小程序上线，依附于头条App； 

◼ 2019年5月 QQ小程序上线，依附于QQApp； 

◼ 2019年10月 美团小程序上线，依附于美团App



### 各个平台为什么都需要支持小程序呢？

第一：**大厂竞争格局中一个重要的一环**

第二：**小程序作为介入H5页面和App之间的一项技术**，他自身很大的优势

+ 体验比传统H5页面要好很多
+ 相当于传统的App，使用起来更加方便，不需要在应用商店中下载安装，甚至注册登录等麻烦的操作。

第三：**小程序可以间接的动态为App添加新功能**

+ 传统的App更新需要先打包，上架到应用商店之后需要通过审核（App Store）
+ 但是小程序可以在App不更新的情况下，动态为自己的应用添加新的功能需求

那么目前在这么多小程序的竞争格局中，哪一个是使用最广泛的呢？

+ 显示是**微信小程序**，目前支付宝、抖音小程序也或多或少有人在使用； 
+ 其实我们透过小程序看本质，他们本身还是**应用和平台之间的竞争**，有最大流量入口的平台，对应的小程序也是用户更多一些；
+ 目前在公司**开发小程序主要开发的还是微信小程序**，其他平台的小程序往往是平台本身的一些公司或者顺手开发的；



### 小程序由谁来开发？

小程序的定位

+ 介于原生App和手机H5页面之间的一个产品定位

小程序是由谁来开发

+ 是由他的技术特点所决定的，比如微信小程序WXML、WXSS、JavaScript
+ 它更接近于我们的前端的开发技术栈，所以下程序是由前端工程师开发

![image-20231119210601385](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20231119210601385.png)



### 开发小程序的技术选型

原生小程序开发： 

+ 微信小程序：https://developers.weixin.qq.com/miniprogram/dev/framework/ 
  + 主要技术包括：WXML、WXSS、JavaScript； 
+ 支付宝小程序：https://opendocs.alipay.com/mini/developer 
  + 要技术包括：AXML、ACSS、JavaScript；

选择框架开发小程序： 

mpvue： 

+ mpvue是一个使用Vue开发小程序的前端框架，也是 支持 微信小程序、百度智能小程序，头条小程序 和 支付宝小程序； 
  + 该框架在2018年之后就不再维护和更新了，所以目前已经被放弃；


wepy：

+ WePY (发音: /'wepi/)是由腾讯开源的，一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己 喜欢的开发风格去开发小程序。 
  +  该框架目前维护的也较少，在前两年还有挺多的项目在使用，不推荐使用；




### uni-app 和 taro

uni-app：（**是一个跨平台解决方案的框架**）

+  由DCloud团队开发和维护；
+ uni-app是一个使用Vue**开发所有前端应用的框架**，开发者编写一套代码，可发布到IOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台

+ **uni-app目前是很多公司的技术选型**，特别是希望适配移动端App的公司；

taro：

+ 由京东团队开发和维护
+ taro是一个开放式**跨端、跨框架解决方案**，支持使用**React/Vue/Nerv等框架**来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用；

+ taro因为本身支持React、Vue的选择，给了我们更加灵活的选择空间； 
  + 特别是在Taro3.x之后，支持**Vue3、React Hook写法**等； 
+ taro['tɑ:roʊ]，泰罗·奥特曼，宇宙警备队总教官，实力最强的奥特曼；

uni-app和taro开发原生App：

+ 无论是适配原生小程序还是原生App，都有**较多的适配问题，所以你还是需要多了解原生的一些开发知识；** 
+ 产品使用**体验整体相较于原生App差很多；** 
+ 也有其他的技术选项来开发原生App：ReactNative、Flutter；



## 二.需要掌握的预备知识

小程序的核心技术主要是三个： 

+  页面布局：**WXML**，类似HTML； 

> 区别:页面中块级元素div,行内元素span,按钮button(元素),小程序中是view,text,button,轮播图swiper-item(组件)

+ 页面样式：**WXSS**，几乎就是CSS(某些不支持，某些进行了增强，但是基本是一致的) ； 
+ 页面脚本：**JavaScript+WXS**(WeiXinScript) ；

如果你之前已经掌握了**Vue或者React等框架**开发，那么学习小程序是更简单的； 

+ 因为里面的**核心思想都是一致的**（比如组件化开发、数据响应式、mustache语法、事件绑定等等）



## 三.开发小程序步骤

申请AppID(开发小程序的唯一标识 -> 开发工具)

### 注册账号 – 申请AppID

**注册账号：申请AppID**

+ 接入流程：https://mp.weixin.qq.com/cgi-bin/wx





### 下载小程序开发工具

小程序的开发工具： 

+ 微信开发者工具：官方提供的开发工具，必须下载、安装； 
+ VSCode：很多人比较习惯使用VSCode来编写代码； 

微信开发者工具下载地址： 

+ https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html



### 使用VSCode开发

推荐一些插件：

![image-20231119220724901](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20231119220724901.png)



## 四.小程序项目结构

![image-20231119223834081](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20231119223834081.png)

json文件最外层是一个对象（json文件中不支持注释）

所有的页面都必须在pages中进行注册

window对窗口进行一些配置



在加载一个项目时，首先加载App相关的文件（创建App实例），然后加载其中一个页面（与App.json文件中的pages的配置相关，优先加载第一个页面）

## 五.小程序开发体验

1. 数据绑定 

2. 列表渲染 
3. 事件监听



+ .wxml文件

```html
<!--1.展示普通文本  -->
<text class="title">我是普通文本</text>

<!-- 2.动态绑定属性 -->
<view class="message">{{message}}</view>

<!-- 3.动态展示列表数据 -->
<view class="movies">
  <!-- for循环block -->
  <block wx:for="{{movies}}" wx:key="*this">
    <view>
      {{item}}-{{index}}
    </view>
  </block>
</view>
```



+ js文件

```js
//实例化一个页面对象
Page({
  /**
   * 页面的初始数据
   */
  data: {
    message:"Hello World",
    movies:["大话西游","独行月球","少年的你","致青春"]
  },
})
```





### 计数器案例实现

+ xml文件

```html
<!-- 4.计数器案例 -->
<view class="counter"> 
  <view class="count">当前计数：{{count}}</view>
  <button size="mini" type="primary" bind:tap="increment">+1</button>
  <button size="mini" type="warn" bind:tap="decrement">-1</button>
</view>
```



+ js文件

```js
Page({
  data: {
    count:0
  },

  // 监听事件方法
  increment() {
    // 修改data中的数据，但是并不会引起页面的刷新（自动监测新数据重新渲染页面，小程序和react中都是这样）
    // this.data.count += 1
    // console.log(this.data.count);

    this.setData({
      count:this.data.count + 1
    })
  },
  decrement() {
    this.setData({
      count:this.data.count + 1
    })
  }
 
})
```





### mvvm架构

vue的mvvm和小程序的MVVM架构对比

MVVM架构的好处

+ DOM listeners：ViewModel层可以将DOM的监听绑定到Model层
+ Data Bindings：ViewModel层可以将数据的变量，响应式的反应到View层

MVVM架构将我们从**命令式编程转移到声明式编程**





## 小程序的配置和架构

### 1 小程序的双线程模型

小程序的宿主环境（运行环境）：**微信客户端**

宿主环境为了执行小程序的各种文件：wxml文件、wxss文件、js文件

当小程序基于WebView（相当于一个原生控件，也包含js引擎）环境下时，WebView的js逻辑、DOM树创建、css解析、样式计算、Layout、Paint（Composite）都发生在同一线程，在webView上执行过多的js逻辑可能阻塞渲染，导致界面卡顿

> web:div/p/h -->元素
>
> 小程序:view/text/button --> 组件
>
> 原生:button/image/view --> 控件

以此为前提，小程序同时考虑了性能与安全，采用了目前称为**双线程模型**的架构

双线程模型：

+ WXML模块和WXSS样式运行于**渲染层**，渲染层使用WebView线程渲染（一个程序又多个页面，会使用多个WebView的线程）
+ js脚本（app.js/home.js等）运行于**逻辑层**，逻辑层使用JSCore运行js脚本
+ 这两个线程都会经由**微信客户端（Native）**进行中转交互



js代码，网络请求，拿到数据对数据进行一个转换时，会单独开一个线程（也就是webview）只负责执行js逻辑，然后通过原生将这些代码交给渲染层的webview进行一个展示，以更多的内存为前提

+ 以前还是交给webview去渲染，仍然是一个网页，现在是通过一个原生的渲染引擎，然后将渲染后的结果直接交给cpu
+ 不需要对每一个页面建立一个webview去进行渲染（js引擎实例），节省了内存时间开销

为了提供更加接近原生的用户体验，在webview渲染之外新增了一个渲染引擎Skyline

在 Skyline 环境下，我们尝试改变这一情况：Skyline 创建了一条**渲染线程**来负责 Layout, Composite 和 Paint 等渲染任务，并在 AppService 中划出一个独立的上下文，来运行之前 WebView 承担的 JS 逻辑、DOM 树创建等逻辑。这种新的架构相比原有的 WebView 架构，有以下特点：

- 界面更不容易被逻辑阻塞，进一步减少卡顿
- 无需为每个页面新建一个 JS 引擎实例（WebView），减少了内存、时间开销
- 框架可以在页面之间共享更多的资源，进一步减少运行时内存、时间开销
- 框架的代码之间无需再通过 JSBridge 进行数据交换，减少了大量通信时间开销



微信现已开放小程序内搜索，开发者可以通过 `sitemap.json` 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。 爬虫访问小程序内页面时，会携带特定的 user-agent：`mpcrawler` 及[场景值](https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html)：`1129`。需要注意的是，若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。



### 小程序的配置文件

小程序的很多**开发需求**被规定在了**配置文件**中。 

为什么这样做呢? 

+ 这样做可以更有利于我们的开发效率； 
+ 并且可以保证开发出来的小程序的某些风格是比较一致的； 
+ 比如导航栏 – 顶部TabBar，以及页面路由等等。 

常见的配置文件有哪些呢? 

+ project.config.json：项目配置文件, 比如项目名称、appid等； 
  +  https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html 
  + 一般改本地配置文件时,改的私有配置project.private.config.json,设置不同步git
+ sitemap.json：小程序搜索相关的； 
  +  https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html



### 全局app配置文件

全局配置比较多, 我们这里将几个比较重要的. 完整的查看官方文档. 

+ https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html 

| 属性   | 类型     | 必填 | 描述               |
| ------ | -------- | ---- | ------------------ |
| pages  | String[] | 是   | 页面路径列表       |
| window | Object   | 否   | 全局的默认窗口表现 |
| tabBar | Object   | 否   | 底部tab栏的表现    |



**pages: 页面路径列表** 

+ 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。 
+ 小程序中所有的页面都是必须在pages中进行注册的。 

**window: 全局的默认窗口展示** 

+ 用户指定窗口如何展示, 其中还包含了很多其他的属性 

**tabBar: 顶部tab栏的展示** 

+ 具体属性稍后我们进行演示



![image-20231201213527822](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20231201213527822.png)





+ 默认wxml只能使用内置组件,如果要使用自定义组件,需要在json文件usingComponents中进行配置

```json
{
  "usingComponents": {},
  // 打开下拉刷新
  "enablePullDownRefresh": true
}
```



+ 开启下拉刷新配置`"enablePullDownRefresh": true,`

+ 监听下拉信息函数:onPullDownRefresh

```js
onPullDownRefresh() {

    console.log("监听用户下拉刷新");

    //模拟网络请求
    setTimeout(()=> {
      wx.stopPullDownRefresh({
        success:(res) => {
          console.log("停止下拉刷新",res);
        }
      })
    },100)
  },

```

+ 监听滚动到底部:onReachBottom

```wxml
<view class="list">
  <block wx:for="{{100}}" wx:key="*this">
    <view>列表数据:{{item}}</view>
  </block>
</view>
```



```js
  // 监听页面滚动到底部
  onReachBottom() {
    console.log("到达底部");
  },
```



+ 距离底部xx距离时就进行刷新`"onReachBottomDistance": 100`

+ 每次滑动到底部新加载30条数据

```js
  // 监听页面滚动到底部
  onReachBottom() {
    console.log("到达底部");
    this.setData({
      listCount:this.data.listCount+30
    })
  },
```



![image-20231209121052566](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20231209121052566.png)



## 小程序包括哪些?以及都有哪些开发模式?(面试)

## 说说你对小程序双线程模型架构的理解(面试)

# day02

## 一、注册小程序

每个小程序都需要在 app.js 中调用 App 函数 注册小程序示例 

+ 在注册时, 可以**绑定对应的生命周期函数**； 
+ 在生命周期函数中, 执行对应的代码； 
+ https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html 

我们来思考：注册App时，我们一般会做什么呢？ 

+ **判断小程序的进入场景** （下拉进入小程序，搜索进入小程序，别人分享进入小程序）
+ **监听生命周期函数**，在生命周期中执行对应的业务逻辑，比如在某个生命周期函数中进行登录操作或者请求网络数据； 
+ **因为App()实例只有一个**，并且是全局共享的（单例对象），所以我们可以将一些共享数据放在这里；



注册整个app实例时调用onLaunch函数，并且在调用函数时传入一个options对象

### 1 注册App函数的作用

### 作用一：判断打开场景

小程序的打开场景较多： 

+ 常见的打开场景：群聊会话中打开、小程序列表中打开、微信扫一扫打开、另一个小程序打开 
+ https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html

如何确定场景（如何获取场景id）? 

+ 在onLaunch和onShow生命周期回调函数中，会有**options参数**，其中有**scene值**；



| 属性     | 类型     | 必填 | 说明                                |
| -------- | -------- | :--- | ----------------------------------- |
| onLaunch | function | 否   | 生命周期回调—监听小程序初始化       |
| onShow   | function | 否   | 生命周期回调—监听小程序启动或切前台 |
| onHide   | function | 否   | 生命周期回调—监听小程序切后台       |



```js
App({
  onLaunch(options) {
    console.log(options);
  },
  onShow(options) {
    console.log("onShow",options);
  },
  onHide() {
    console.log("onHide");
  }
})
```

### 作用二：定义全局App的数据

作用二：可以在Object中定义全局App的数据

这里的数据不是响应式的，在其他地方将数据改变掉，这里是不会知道的，不会重新加载数据显示新的数据

+ 这里共享的数据是一些固定的数据，比如token，加载之后不会在改变

![image-20231211130107050](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20231211130107050.png)

定义的数据可以在其他任何页面中访问：

+ page中的生命周期函数onLoad：监听页面加载

```js
Page({
  data: {
    userInfo:{}
  },

  onLoad() {
    // 获取共享的数据，app中的数据
    // 1.获取app的实例对象
    const app = getApp()

    // 2.从app实例对象中获取数据
    const token = app.globalData.token
    const userInfo = app.globalData.userInfo
    console.log(token,userInfo);

    // 3.拿到token目的发送网络请求

    // 4.将数据展示的到界面上去
    this.setData({userInfo})
    // this.data.userInfo = userInfo 通过这样去改变的数据不是实时的
  }

})
```

### 作用三 – 生命周期函数

作用三：在生命周期函数中，完成应用程序启动后的初始化操作

+ 比如登录操作（这个后续会详细讲解）； 
+ 比如读取本地数据（类似于token，然后保存在全局方便使用） 
+ 比如请求整个应用程序需要的数据；

```js
onLaunch(options) {
    // 0.从本地获取数据token/userInfo
    const token = wx.getStorageSync("token")
    const userInfo = wx.getStorageSync('userInfo')

    // 1.进行登录操作（判断逻辑）
    // 将登录成功的数据，保存到storage
    if(!token || !userInfo) {
      console.log("登录操作");
      wx.setStorageSync('token', "tjjtoken")
      wx.setStorageSync('userInfo', {nickname:"tjj",level:"100"})
    }

    // 2.将获取到的数据保存到globalData中
    this.globalData.token = token
    this.globalData.userInfo = userInfo

    // 3.发送网络请求，优先请求一些必要的数据
    wx.request({
      url: 'url',
    })


  },
```



+ wxml文件

![image-20231217113354072](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20231217113354072.png)

+ js文件

```js
// index.js
Page({
  data:{
    pages:[
      {name:"01_初体验",path:"/pages/01_test/index"}
    ]
  },

  onBtnClick(event) {
    console.log("btnclick",event);
    const item = event.target.dataset.item

    wx.navigateTo({
      url: item.path,
    })
  }
})
```



+ 注意：小程序中绑定属性都是match语法，而vue中使用v-bind（语法糖：）

+ data-*自定义属性

### 知识点管理

```js
// index.js
Page({
  data: {
    pages: [
      { name: "01_注册页面", path: "/pages/01_register_page/index" },
      { name: "02_常见组件", path: "/pages/02_common_cpns/index" },
      { name: "03_学习WXSS", path: "/pages/03_learn_wxss/index" },
    ]
  },
  onBtnClick(event) {
    // 1.获取item
    const item = event.target.dataset.item

    // 2.跳转路径
    wx.navigateTo({
      url: item.path,
    })
  }
})
```

wxml

```html
<!-- home首页 -->
<view class="pages">
  <block wx:for="{{pages}}" wx:key="name">
    <button
      class="btn"
      type="primary" 
      bindtap="onBtnClick"
      data-item="{{item}}"
    >
      {{ item.name }}
    </button>
  </block>
</view>
```

+ 点击不同的按钮如何区分

+ 在button中通过data-*添加一个自定义属性（data-item = ’aaa‘）
+ 在点击事件中的参数event中，event.target.dataset中会添加一个对象，其中包含一个item属性，其值就是传入的aaa



## 二、注册页面 – Page函数

小程序中的每个页面, 都有一个对应的js文件, 其中调用Page函数注册页面示例 

+ 在注册时, 可以绑定**初始化数据、生命周期回调、事件处理函数**等。 
+ https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html 

我们来思考：注册一个Page页面时，我们一般需要做什么呢？ 

+ 1.在生命周期函数中发送网络请求，从服务器获取数据； 
+ 2.初始化一些数据，以方便被wxml引用展示； 
+ 3.监听wxml中的事件，绑定对应的事件函数； 
+ 4.其他一些监听（比如页面滚动、上拉刷新、下拉加载更多等）；

注册页面的第一个操作

#### 发送网络请求

```html
<view class="banner">
  <swiper circular autoplay indicator-dots="{{true}}">
    <block wx:for="{{banners}}" wx:key="acm">
      <swiper-item>
        <!-- image组件默认宽度和高度: 320x240 -->
        <image mode="widthFix" src="{{item.image}}"></image>
      </swiper-item>
    </block>
  </swiper>
</view>
```

+ circular是否采用衔接滑动
+ autoplay自动播放
+ indicator-dots指示器
+ mode="widthFix"：使高度进行自适应

```js
// pages/01_初体验/index.js
Page({
  data: {
    banners: [],
    recommends: [],
  },
  // 1.作用一: 发送网络请求, 请求数据
  onLoad() {
    console.log("onLoad");

    // 发送网络请求
    wx.request({
      url: "http://123.207.32.32:8000/home/multidata",
      success: (res) => {
        const data = res.data.data
        const banners = data.banner.list
        const recommends = data.recommend.list
        this.setData({ banners, recommends })
      }
    })
  },


})
```

#### 初始化本地数据

```js
// pages/01_初体验/index.js
Page({
  data: {

    // 2.作用二: 定义本地固定的数据
    counter: 100,

    btns: ["red", "blue", "green", "orange"]
  },

})
```



```html
<view class="counter">
  <view>当前计数: {{ counter }}</view>
</view>
```



#### 绑定wxml中产生事件后的回调函数



```JS
// pages/test/index.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    btns:['red','orange','pink','purple']
  },

  onBtn1Click() {
    console.log('btn1');
  },
  onBtnClick(event) {
    console.log(event.target.dataset.item);
  },

  // 下拉刷新、页面滚动到底部、页面滚动位置监听
  onPullDownRefresh() {
    console.log("下拉刷新");
  },
  onReachBottom() {
    console.log("到达底部");
  },
  onPageScroll(event) {
    console.log("onPageScroll:",event);
  }
})
```



```html
<!--pages/test/index.wxml-->
<view>
  <button bindtap="onBtn1Click">按钮1</button>
  <block wx:for="{{btns}}" wx:key="*this">
    <button 
      bindtap="onBtnClick" 
      data-item="{{item}}"
      style="background-color: {{item}};">{{item}}</button>
  </block>
</view>

<view>
  <block wx:for="{{30}}" wx:key="*this">
    <view>列表数据：{{item}}</view>
  </block>
</view>
```



+ 注意：小程序中仍然是options API

上拉和下拉的监听

监听页面的下拉刷新和上拉加载更多： 

+ 步骤一：配置页面的json文件； 
+ 步骤二：代码中进行监听；



### Page页面生命周期

![image-20240221114143408](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240221114143408.png)

一个线程是负责解析wxml、wxss文件

+ 初始化，然后等待数据，不会立即进行渲染（例如mastch语法中的数据还没有拿到）
+ 得到数据之后会进行第一次渲染，
+ 然后Notify发送通知
+ 得到新的数据之后重新渲染

一个线程负责js、json文件

+ 首先进行create，就是创建page实例，
+ 然后执行onLoad、onShow生命周期，
+ 然后通过微信客户端将数据传递给view 线程
+ 在页面第一次被渲染之后执行onReady
+ 将最新改变的数据发送给view线程
+ 将小程序隐藏到后台时会执行onHide生命周期函数
+ 返回到前台时会再次执行onShow函数
+ 当页面销毁掉时（比如返回时，当前页面就会被销毁），会执行onUnload函数



# day03

## Text文本组件

**Text组件用于显示文本, 类似于span标签, 是行内元素**

+ **user-select属性**决定文本内容是否可以让用户选中（默认false）
+ space有三个取值(了解) 
+ decode是否解码(了解) 
  + decode可以解析的有  < > & '    

## Button按钮组件

Button组件用于创建按钮，默认**块级元素**

![image-20240221121927425](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240221121927425.png)

+ hover-class：指定按钮按下去的样式类，当 `hover-class="none"` 时，没有点击态效果



+ open-type：微信开放能力

| 合法值      | 说明                                                         | 最低版本                                                     |
| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| contact     | 打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息，[具体说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/customer-message.html) | [1.1.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| getUserInfo | 获取用户信息，可以从bindgetuserinfo回调中获取到用户信息 （*小程序插件中不能使用*） | [1.3.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

+ getUserProfile：获取用户信息。页面产生点击事件（例如 `button` 上 `bindtap` 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 `userInfo`。该接口用于替换 `wx.getUserInfo`

```html
<view>
  <button bindtap="getUserInfo">获取用户信息</button>
  <button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber">获取手机号</button>
</view>
```



```js
// pages/test/index.js
Page({
  getUserInfo() {
    // 调用API获取用户信息
    // 1.早期小程序的API，基本都是不支持Promise
    // 2.后期小程序支持promise风格
    wx.getUserProfile({
      desc: 'desc',
      // success:(res) => {
      //   console.log(res);
      // } 
    }).then(res => {
      console.log(res);
    })
  },
  getPhoneNumber(event) {
    console.log(event);
  } 
})
```



## View视图组件 

视图组件（块级元素，独占一行，通常用作容器组件）

+ 相当于div

| 属性                   | 类型    | 默认值 | 必填 | 说明                                                         | 最低版本                                                     |
| :--------------------- | :------ | :----- | :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| hover-class            | string  | none   | 否   | 指定按下去的样式类。当 `hover-class="none"` 时，没有点击态效果 | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hover-stop-propagation | boolean | false  | 否   | 指定是否阻止本节点的祖先节点出现点击态                       | [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hover-start-time       | number  | 50     | 否   | 按住后多久出现点击态，单位毫秒                               | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hover-stay-time        | number  | 400    | 否   | 手指松开后点击态保留时间，单位毫秒                           | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

+ `tip`: 如果需要使用滚动视图，请使用 [scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)

## Image图片组件

Image组件用于显示图片，有如下常见属性 



+ 其中src可以是本地图片，也可以是网络图片 
+ Mode属性使用也非常关键，详情查看官网： 
  + mode：图片的剪裁缩放模式，默认值为scaleToFill
  + https://developers.weixin.qq.com/miniprogram/dev/component/image.html 
+ **注意：image组件默认宽度320px、高度240px**



选择本地图片，将本地图片用iamge展示出来

```html
<view>
  <button bindtap="onChoseImage">选择图片</button>
  <image src="{{chooseImageUrl}}" mode="aspectFill"></image>
</view>
```



```js
// pages/test/index.js
Page({
  data: {
    chooseImageUrl:''
  },

  onChoseImage() {
    wx.chooseMedia({
      mediaType:"image"
    }).then(res => {
      const imagePath = res.tempFiles[0].tempFilePath
      this.setData({chooseImageUrl:imagePath})
      console.log(res);
    })
  }
})
```

+ API wx.chooseMedia



## ScrollView滚动组件

scroll-view可以实现局部滚动，常见属性如下：

```html
<scroll-view class="container scroll-x" scroll-y>
  <block wx:for="{{viewColors}}" wx:key="*this">
    <view class="item" style="background-color: {{item}};">{{item}}</view>
  </block>
</scroll-view>
```



```js
// pages/test/index.js
Page({
  data: {
    viewColors: ["red", "blue", "green", "skyblue", "purple", "yellow"]
  },
})
```



```css
/* pages/test/index.wxss */
.container {
  background-color: orange;
  height: 150px;
}
.item {
  width: 100px;
  height: 100px;
}
```



#### 水平滚动

+ 通过flex进行水平布局
+ 设置enable-flex
+ 设置flex-shrink: 0;
+ 设置水平滚动scroll-x

```html
<scroll-view 
  class="container scroll-x" 
  scroll-x 
  enable-flex
  bindscrolltoupper="onScrollToUpper"
  bindscrolltolower="onScrollToLower"
  bindscroll="onScroll">
  <block wx:for="{{viewColors}}" wx:key="*this">
    <view class="item" style="background-color: {{item}};">{{item}}</view>
  </block>
</scroll-view>
```



```css
/* pages/test/index.wxss */
.container {
  background-color: orange;
  height: 150px;
}
.scroll-x {
  display: flex;

}
.item {
  width: 100px;
  height: 100px;
  flex-shrink: 0;
}
```



```js
// pages/test/index.js
Page({
  data: {
    viewColors: ["red", "blue", "green", "skyblue", "purple", "yellow"]
  },

  // 监听scroll-view滚动
  onScrollToUpper() {
    console.log("滚动到最顶部/左边");
  },
  onScrollToLower() {
    console.log("滚到到最底部/右边");
  },
  onScroll(event) {
    console.log("scrollview发生了滚动:", event);
  }
})
```



注意事项： 

+ 实现滚动效果必须添加scroll-x或者scroll-y属性（只需要添加即可，属性值相当于为true了） 
+ 垂直方向滚动必须设置scroll-view一个高度





## 组件的共同属性

![image-20240221151629370](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240221151629370.png)



#### input实现双向绑定

```html
<input type="text" model:value = "{{message}}"/>
```



# day04

WXSS-WXML-WXS语法

## 1 WXSS编写程序样式 

小程序的样式写法

页面样式的三种写法： 

+ 行内样式、页面样式、全局样式 
+ 三种样式都可以作用于页面的组件 

如果有相同的样式： 

+ 优先级依次是：行内样式 > 页面样式 > 全局样式
+ 指南-> 小城去框架->视图层

| 选择器           | 样例             | 样例描述                                       |
| :--------------- | :--------------- | :--------------------------------------------- |
| .class           | `.intro`         | 选择所有拥有 class="intro" 的组件              |
| #id              | `#firstname`     | 选择拥有 id="firstname" 的组件                 |
| element          | `view`           | 选择所有 view 组件                             |
| element, element | `view, checkbox` | 选择所有文档的 view 组件和所有的 checkbox 组件 |
| ::after          | `view::after`    | 在 view 组件后边插入内容                       |
| ::before         | `view::before`   | 在 view 组件前边插入内容                       |



### 尺寸单位

+ rpx（responsive pixel）: 可以**根据屏幕宽度进行自适应**，规定屏幕宽为750rpx。 
+ 如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理 像素。
+ 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准

## 2 Mustache语法绑定

WXML基本格式： 

+ 类似于HTML代码：比如可以写成**单标签**，也可以写成**双标签**； 
+ 必须有**严格的闭合**：没有闭合会导致编译错误 
+ **大小写敏感**：class和Class是不同的属性 

开发中, 界面上展示的数据并不是写死的, 而是会根据服务器返回的数据，或者用户的操作来进行改变. 

+ 如果使用原生JS或者jQuery的话, 我们需要通过操作DOM来进行界面的更新. 
+ 小程序和Vue一样, 提供了插值语法: Mustache语法(双大括号)

```js
// pages/04_learn_wxml/index.js
Page({
  data: {
    message: "Hello World",
    firstname: "kobe",
    lastname: "bryant",
    date: new Date().toLocaleDateString(),

  },
})
```

```html
<view>{{ date }}</view> //2024/2/21
```



### 逻辑判断 wx:if – wx:elif – wx:else

某些时候, 我们需要根据条件来决定一些内容是否渲染： 

+ 当条件为true时, view组件会渲染出来 
+ 当条件为false时, view组件不会渲染出来

```html
<!-- 2.条件判断 -->
<view wx:if="{{score > 90}}">优秀</view>
<view wx:elif="{{score > 80}}">良好</view>
<view wx:elif="{{score >= 60}}">及格</view>
<view wx:else>不及格</view>
```

+ 在小程序中只要绑定逻辑层中的数据都要使用mustache语法
+ v-for 不渲染的的组件在DOM树中是不存在的
+ v-show display为none

##  

### hidden属性

hidden属性:（与v-show对应） 

+ hidden是所有的组件都默认拥有的属性； 
+ 当hidden属性为true时, 组件会被隐藏； 
+ 当hidden属性为false时, 组件会显示出来；

hidden和wx:if的区别

+ hidden控制隐藏和显示是控制是否添加hidden属性 
+ wx:if是控制组件是否渲染的



切换案例

```html
<!-- 3.hidden属性:v-show -->
<!-- 基本使用 -->
<view hidden>我是hidden的view</view>

<!-- 切换案例 -->
<button bindtap="onChangeTap">切换</button>
<view hidden="{{isHidden}}">哈哈哈哈</view>
<view wx:if="{{!isHidden}}">呵呵呵呵</view>
```



```js
// pages/04_learn_wxml/index.js
Page({
  data: {
    isHidden: false,
  },

  onChangeTap() {
    this.setData({
      isHidden: !this.data.isHidden
    })
  }
})
```

+ 频繁切换就采用hidden，反之则采用wx.if

## 3 WXML的条件渲染 

## 4 WXML的列表渲染

为什么使用wx:for？ 

+ 我们知道，在实际开发中，服务器经常返回各种**列表数据**，我们不可能一一从列表中取出数据进行展示； 
+ 需要通过**for循环的方式，遍历所有的数据，一次性进行展示**； 

在组件中，我们可以使用wx:for来遍历一个数组 （字符串 - 数字） 

+ 默认情况下，遍历后在wxml中可以使用一个**变量index**，保存的是当前遍历数据的下标值。 
+ 数组中对应某项的数据，使用**变量名item**获取。

```html
<!-- 4.列表展示 -->
<!-- 4.1.wx:for基本使用 -->
<!-- 遍历data中的数组 -->
<view class="books">
  <view wx:for="{{books}}" wx:key="id">
    <!-- item: 每项内容, index: 每项索引 -->
    {{item.name}}-{{item.price}}
  </view>
</view>
<!-- 遍历数字 -->
<view class="number">
  <view wx:for="{{10}}" wx:key="*this">
    {{ item }}
  </view>
</view>
<!-- 遍历字符串 -->
<view class="str">
  <view wx:for="coderwhy" wx:key="*this">
    {{ item }}
  </view>
</view>
```



```js
  // pages/04_learn_wxml/index.js
  Page({
    data: {
      books: [
        { id: 111, name: "代码大全", price: 98 },
        { id: 112, name: "你不知道JS", price: 87 },
        { id: 113, name: "JS高级设计", price: 76 },
      ]
    },
  })
```



+ *this表示的是item本身，而item本身是一个对象类型，对象类型绑定到key的时候会将其转换为字符串，最终都是[Object]，那么这个key就不再唯一，所以当这个变量是一个对象时就不能采用这种方式绑定this
+ 方式二：自定义的字符出，例如id，会自动取item对象中的id属性作为key



### block标签

什么是block标签？ 

+ 某些情况下，我们需要使用 wx:if 或 wx:for时，可能需要包裹一组组件标签 
+ 我们希望对这一组组件标签进行整体的操作，这个时候怎么办呢？

 注意：并不是一个组件，它仅仅是一个**包装元素**，**不会在页面中做任何渲染，只接受控制属性**。 



使用block有两个好处： 

1）将需要进行遍历或者判断的内容进行包裹。 

2）将遍历和判断的属性放在block便签中，不影响普通属性的阅读，提高代码的可读性。



 默认情况下，item – index的名字是固定的 

+ 但是某些情况下，我们可能想使用其他名称 
+ 或者当出现多层遍历时，名字会重复 

这个时候，我们可以**指定item和index的名称**：

```html
<!-- 4.2. 细节补充: block-item/index名称-key的使用 -->
<view class="books">
  <block wx:for="{{books}}" wx:key="id" wx:for-item="book" wx:for-index="i">
    <view>{{ book.name }}-{{ book.price }}-{{ i }}</view>
  </block>
</view>
```



### 列表渲染 – key作用

我们看到，使用wx:for时，会报一个警告： 

+ 这个提示告诉我们，可以添加一个key来提供性能。

 为什么需要这个key属性呢？ 

+ 这个其实和小程序内部也使用了**虚拟DOM有关系**（和Vue、React很相似）。 
+ 当某一层有很多相同的节点时，也就是列表节点时，我们希望插入、删除一个新的节点，可以更好的复用节点； 

wx:key 的值以两种形式提供 

+ **字符串**，代表在 for 循环的 array **中 item 的某个 property**，该 property 的值需要是列表中唯一的字符串或数字，且不能 动态改变。 
+ **保留关键字 *this** 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。

## 5 WXS语法基本使用 

**WXS（WeiXin Script）**是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 

+ 官方：WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。（不过基本一致）

为什么要设计WXS语言呢？ 

+ 在WXML中是不能直接调用Page/Component中定义的函数的. (在vue中是运行的)
+ 不能调用的原因是因为小程序是双线程架构，而之所以能够绑定数据和监听事件是通过原生客户端进行交互，微信底层去设计函数的调用过程比较繁琐

![image-20240221180115194](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240221180115194.png)

+ 但是某些情况, 我们可以希望使用函数来处理WXML中的数据(类似于Vue中的过滤器)，这个时候就使用WXS了

WXS使用的限制和特点： 

+ WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行； 
+ WXS 的**运行环境和其他 JavaScript 代码是隔离的**，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序 提供的API； 
+ 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备 上二者运行效率 无差异；

### WXS的写法

WXS有两种写法： 

+ -写在标签中 
+ -写在以.wxs结尾的文件中

```html
<wxs module="format">
  function formatPrice(price) {
    return "¥" + price
  }

  // 必须导出后, 才能被其他地方调用: 必须使用CommonJS导出
  module.exports = {
    formatPrice: formatPrice
  }
</wxs>
<view class="books">
  <block wx:for="{{books}}" wx:key="id">
    <view>name:{{item.name}}-price:{{format.formatPrice(item.price)}}</view>
  </block>
</view>
```



```html
<!-- 2.方式二: 独立的文件, 通过src引入 -->
<wxs module="format" src="/utils/format.wxs"></wxs>

<view class="books">
  <block wx:for="{{books}}" wx:key="id">
    <view>name:{{item.name}}-price:{{format.formatPrice(item.price)}}</view>
  </block>
</view>
```



 标签的属性： 

每一个 .wxs 文件和  标签都是一个单独的模块。 

每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见；

 一个模块要想对外暴露其内部的私有变量与函数，只能通过 module.exports 实现；

## 6 WXS语法案例练习

### WXS的练习（一）

使用两种方式来计算一个数组的和：

### WXS的练习（二）

案例练习题目： 

+ 题目一：传入一个数字，格式化后进行展示（例如36456，展示结果3.6万）； 

```html
<wxs module="format" src="/utils/format.wxs"></wxs>
<view>播放量{{format.formatCount(playCount)}}</view>
```



```js
function formatCount(count) {
  count = Number(count)
  if(count >= 100000000) {
    return (count/100000000).toFixed(1) + '亿'
  } else if(count >= 10000) {
    return (count / 10000).toFixed(1) + "万"
  } else  {
    return count
  }
}

// 必须导出后, 才能被其他地方调用: 必须使用CommonJS导出
module.exports = {
  formatCount: formatCount,
  formatTime: formatTime
}
```



+ 题目二：传入一个事件，格式化后进行展示（例如100秒，展示结果为01:40）；

```html
<wxs module="format" src="/utils/format.wxs"></wxs>
<view>播放量{{format.formatCount(playCount)}}</view>
<view>{{format.formatTime(currentTime)}}/{{format.formatTime(duration)}}</view>
```



```js
// function padLeft(time) {
//   if((time + "").length >= 2) return time
//   return "0" + time
// }

function padLeft(time) {
  time = time + ""
  return ("00" + time).slice(time.length)
}

function formatTime(time) {
  // 1.获取时间
  var minute = Math.floor(time/60)
  var second = Math.floor(time) % 60

  return padLeft(minute) + ":" + padLeft(second)
}

// 必须导出后, 才能被其他地方调用: 必须使用CommonJS导出
module.exports = {
  formatPrice: formatPrice,
  calcPrice: calcPrice,
  formatCount: formatCount,
  formatTime: formatTime
}
```



# day04 事件处理

## 1 小程序的事件监听

什么时候会产生事件呢？ 

+ 小程序需要经常和**用户进行某种交互**，比如点击界面上的某个按钮或者区域，比如滑动了某个区域； 
+ 事件是**视图层到逻辑层的通讯方式**； 
+ 事件可以**将用户的行为反馈到逻辑层**进行处理； 
+ 事件可以**绑定在组件上**，当**触发事件时**，就会**执行逻辑层中对应的事件处理函数**； 
+ 事件对象**可以携带额外信息**，如 id, dataset, touches； 



事件时如何处理呢？

+ 事件是**通过bind/catch这个属性**绑定在组件上的（和普通的属性写法很相似, 以key=“value”形式）；
+  key**以bind或catch开头**, 从1.5.0版本开始, **可以在bind和catch后加上一个冒号**； 
+ 同时在当前页面的Page构造器中**定义对应的事件处理函数**, 如果没有对应的函数, 触发事件时会报错； 
+ 比如当用户点击该button区域时，达到触发条件生成事件tap，该事件处理函数会被执行，同时还会收到一个事件对象 event。、

组件的特殊事件

某些组件会有自己特性的事件类型，大家可以在使用组件时具体查看对应的文档 

+ 比如input有bindinput/bindblur/bindfocus等 
+ 比如scroll-view有bindscrolltowpper/bindscrolltolower等

这里我们讨论几个组件都有的, 并且也比较常见的事件类型

| 类型               | 触发条件                                                     | 最低版本                                                     |
| :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| touchstart         | 手指触摸动作开始                                             |                                                              |
| touchmove          | 手指触摸后移动                                               |                                                              |
| touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                         |                                                              |
| touchend           | 手指触摸动作结束                                             |                                                              |
| tap                | 手指触摸后马上离开                                           |                                                              |
| longpress          | 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 | [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| longtap            | 手指触摸后，超过350ms再离开（推荐使用longpress事件代替）     |                                                              |
| transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发    |                                                              |
| animationstart     | 会在一个 WXSS animation 动画开始时触发                       |                                                              |
| animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                   |                                                              |
| animationend       | 会在一个 WXSS animation 动画完成时触发                       |                                                              |
| touchforcechange   | 在支持 3D Touch 的 iPhone 设备，重按时会触发                 | [1.9.90](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

## 2 常见事件类型划分

## 3 事件对象属性分析

### 事件对象event

当某个事件触发时, 会产生一个事件对象, 并且这个对象被传入到回调函数中, 事件对象有哪些常见的属性呢?

| 属性                                                         | 类型    | 说明                           | 基础库版本                                                   |
| :----------------------------------------------------------- | :------ | :----------------------------- | :----------------------------------------------------------- |
| [type](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#type) | String  | 事件类型                       |                                                              |
| [timeStamp](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#timeStamp) | Integer | 事件生成时的时间戳             |                                                              |
| [target](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#target) | Object  | 触发事件的组件的一些属性值集合 |                                                              |
| [currentTarget](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#currenttarget) | Object  | 当前组件的一些属性值集合       |                                                              |
| [mark](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#mark) | Object  | 事件标记数据                   | [2.7.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |





### currentTarget和target的区别

+ target触发事件的元素
+ currentTarget处理事件的元素

![image-20240222012611900](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222012611900.png)



```html
<!-- 2.event中target和currentTarget区别 -->
<view id="outer" class="outer" data-name="why" bindtap="onOuterViewTap">
  <view id="inner" class="inner"></view>
</view>
```



```js
  onOuterViewTap(event) {
    // 1.target触发事件的元素
    // 2.currentTarget处理事件的元素
    console.log("onOuterViewTap:", event);
    console.log(event.target);
    console.log(event.currentTarget);

    // 3.获取自定义属性: name(如果通过event.target是拿不到的，因为inner元素上没有自定义属性name)
    const name = event.currentTarget.dataset.name
    console.log(name);
  },
```



1.在touchend中不同 

2.多手指触摸时不同

![image-20240222013932418](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222013932418.png)

+ 区别一：多指触摸时，changeTouches记录的改变的手指触摸的点，而touches是所有手指的触摸点的信息
+ 区别二：bindtouchend移开触摸时，没有手指，所以其中的touches为空，而changeTouches为变化的触摸点的信息

```HTML
<!-- 3.event中touches和changeTouches区别 -->
<view
  class="touches"
  bindtap="onTouchTap"
  bindlongpress="onLongPress"
  bindtouchend="onTouchEnd"
>
  多指触摸
</view>
```

```js
  // 监听触摸事件
  onTouchTap(event) {
    console.log("tap:", event);
  },
  //当触发长按触摸事件后，就不会触发触摸点击事件onTouchTap
  onLongPress(event) {
    console.log("long:", event);
  },
  onTouchEnd(event) {
    console.log("end:", event);
  },
```



![image-20240222013350947](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222013350947.png)

## 4 事件参数传递方法

**当视图层发生事件时，某些情况需要事件携带一些参数到执行的函数中**, 这个时候就可以通过data-属性来完成： 

在vue中可以直接通过函数调用的方式，将一些参数传递给指定的函数中（@click=“itemClick(index,item)”）

+ 格式：data-属性的名称 
+ 获取：e.currentTarget.dataset.属性的名称

```html
<!-- 4.event的参数传递 -->
<view 
  class="arguments"
  bindtap="onArgumentsTap"
  data-name="why"
  data-age="18"
  data-height="1.88"
>
  参数传递
</view>
```



```js
  // 监听事件, 并且传递参数
  onArgumentsTap(event) {
    console.log("onArgumentsTap:", event);
    const { name, age, height } = event.currentTarget.dataset
    console.log(name, age, height);
  },
```



## 5 事件传递案例练习



```html
<!-- 5.tab-control案例(重要) -->
<view class="tab-control">
  <block wx:for="{{ titles }}" wx:key="*this">
    <view 
      class="item {{index === currentIndex ? 'active': ''}}"
      bindtap="onItemTap"
      data-index="{{index}}"
    >
      <text class="title">{{ item }}</text>
    </view>
  </block>
</view>
```



```js
Page({
  data: {
    titles: ["手机", "电脑", "iPad", "相机"],
    currentIndex: 0
  },

  onItemTap(event) {
    const currentIndex = event.currentTarget.dataset.index
    console.log(currentIndex);
    this.setData({ currentIndex })
  },
})
```



```css
/* tab-control */
.tab-control {
  display: flex;
  height: 40px;
  line-height: 40px;
  text-align: center;
}

.tab-control .item {
  flex: 1;
}

.tab-control .item.active {
  color: #ff8189;
}

.tab-control .item.active .title {
  border-bottom: 3px solid #ff8189;
  padding: 5px;
}
```



## 6 冒泡和捕获的区别

```html
<!-- 6.捕获和冒泡阶段 -->
<view class="view1" capture-bind:tap="onView1CaptureTap" bindtap="onView1Tap">
  <view class="view2" capture-bind:tap="onView2CaptureTap" bindtap="onView2Tap">
    <view class="view3" capture-bind:tap="onView3CaptureTap" bindtap="onView3Tap"></view>
  </view>
</view>
```



![image-20240222030242472](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222030242472.png)

+ 对于事件捕获，在某一阶段捕获到事件之后希望停止，不再向内部进行捕获
+ bind捕获到事件之后继续向下传递，而catch则会阻止事件继续向下传递
+ 给逻辑层传递数据的另一种方式：mark

```html
<!-- 8.给逻辑传递数据, 另外一种方式: mark -->
<view 
  class="mark"
  bindtap="onMarkTap"
  data-name="why"
  data-age="18"
  mark:name="kobe"
  mark:age="30"
>
 <text mark:address="洛杉矶" class="title">mark</text>
</view>
```



```js
  // mark的数据传递
  onMarkTap(event) {
    console.log(event);
    const data1 = event.target.dataset
    console.log(data1);

    const data2 = event.mark
    console.log(data2);
  }
```



# day05 小程序组件化开发

## 1 小程序组件化思想

> 将我们要开发出来的一个整体的项目，可以划分为一个个的组件，单独开发一个组件然后将这些组件组合到一起形成我们整个应用程序，所有开发的组件可以形成一个组件树，每个组件都可以拥有自己的子组件，最终会形成一个树结构

小程序在刚刚推出时是不支持组件化的, 也是为人诟病的一个点： 

+ 但是从v1.6.3开始, 小程序开始支持自定义组件开发, 也让我们更加方便的在程序中使用组件化. 

组件化思想的应用： 

+ 有了组件化的思想，我们在之后的开发中就要充分的利用它。 
+ 尽可能的将页面拆分成一个个**小的、可复用的组件**。 
+ 这样让我们的代码**更加方便组织和管理，并且扩展性也更强**。 

所以，组件是目前小程序开发中，非常重要的一个篇章，要认真学习（不过学习Vue的过程中我们已经强调过很多次了）。

### 创建一个组件

类似于页面，自定义组件由 json wxml wxss js 4个文件组成。 

+ 按照我的个人习惯, 我们会先在根目录下创建一个文件夹； 
+ components, 里面存放我们之后**自定义的公共组件**； 
+ 常见一个自定义组件 my-cpn: 包含对应的四个文件；

自定义组件的步骤： 

+ 1.首先需要在 json 文件中进行自定义组件声明（将component 字段设 为 true 可这一组文件设为自定义组件）： 
+ 2.在wxml中编写属于我们组件自己的模板 
+ 3.在wxss中编写属于我们组件自己的相关样式 
+ 4.在js文件中, 可以定义数据或组件内部的相关逻辑(后续我们再使用)

> component组件和page的区别在于json文件中多了一项配置：`"component": true,`

## 2 自定义组件的过程

一些需要注意的细节： 

+ **自定义组件也是可以引用自定义组件**的，引用方法类似于页面引用自定义组件的方式（使用usingComponents 字段）。 
+ 自定义组件和页面所在项目根目录名 **不能以“wx-”为前缀**，否则会报错。
+ 如果在**app.json的usingComponents声明某个组件**，那么**所有页面和组件可以直接使用该组件**。

在其他页面使用自定义组件时要在json文件中进行注册

```json
{
  "usingComponents": {
    "section-info": "/components/section-info/section-info",
    "test-style": "/components/test-style/test-style",
    "tab-control": "/components/tab-control/tab-control"
  }
}
```



## 3 组件样式实现细节

（小程序不推荐使用id选择器、属性选择器、标签选择器）

课题一：组件内的样式 对 外部样式 的影响

+ 结论一：组件内的class样式，只对组件wxml内的节点生效, 对于引用组件的Page页面不生效。 
+ 结论二：组件内不能使用id选择器、属性选择器、标签选择器

课题二：外部样式 对 组件内样式 的影响

+ 结论一：外部使用class的样式，只对外部wxml的class生效，对组件内是不生效的 
+ 结论二：外部使用了id选择器、属性选择器不会对组件内产生影响  结论三：外部使用了标签选择器，会对组件内产生影响 

课题三：如何让class可以相互影响

+ 在**Component对象**中，可以传入一个options属性，其中options属性中有一个styleIsolation（隔离）属性。 
+ styleIsolation有三个取值： 
  + **isolated** 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（默认取值）；
  + **apply-shared** 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面； 
  + **shared** 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置 了

```js
Component({
  options: {
    styleIsolation: "shared"
  }
})
```



## 4 组件使用过程通信

![image-20240222222351959](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222222351959.png)

 很多情况下，组件内展示的内容（数据、样式、标签），并不是在组件内写死的，而且可以由使用者来决定。

### 向组件传递数据 - properties

给组件传递数据：

+ 大部分情况下，组件只负责布局和样式，内容是由使用组件的对象决定的；
+ 所以，我们经常需要从外部传递数据给我们的组件，让我们的组件来进行展示；

如何传递呢？ 

+ 使用properties属性；

支持的类型：

+ String、Number、Boolean  Object、Array、null（不限制类型） 

默认值：

+ 可以通过value设置默认值；

```js
  properties: {
    title:{
      type:String,
      value:"默认标题"
    },
    content:{
      type:String,
      value:"默认内容"
    }
  },
```

+ 组件

```html
<view class="section">
  <view class="title">{{ title }}</view>
  <view class="content info">{{ content }}</view>
</view>
```

+ 页面

```html
<section-info title="我与地坛" content="要是有些事情我没说, 别以为是我忘记了"/>
<section-info title="黄金时代" content="在我一生中最好的黄金时代, 我想吃, 我想爱"/>
```



### 向组件传递样式 - externalClasses

给组件传递样式：

+ 有时候，我们不希望将样式在组件内固定不变，而是外部可以决定样式。

这个时候，我们可以使用externalClasses属性：

1.在Component对象中，定义externalClasses属性 

2.在组件内的wxml中使用externalClasses属性中的class 

3.在页面中传入对应的class，并且给这个class设置样式



### 组件向外传递事件 – 自定义事件

![image-20240222163609204](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222163609204.png)

+ 页面

```html
<section-info 
  info="abc" 
  title="我与地坛" 
  content="要是有些事情我没说, 别以为是我忘记了"
  bind:titleclick="onSectionTitleClick"
/>
<section-info info="cba" title="黄金时代" content="在我一生中最好的黄金时代, 我想吃, 我想爱"/>
```

```js
  onSectionTitleClick(event) {
    console.log("区域title发生了点击", event.detail);
  },
```



+ 组件

```html
<view class="section">
  <view class="title" bindtap="onTitleTap">{{ title }}</view>
  <view class="content info">{{ content }}</view>
</view>
```



```js
  methods: {
    onTitleTap() {
      console.log("title被点击了~");
      this.triggerEvent("titleclick", "aaa")
    }
  }
```



### 自定义组件练习

```html
<view class="tab-control">
  <block wx:for="{{ titles }}" wx:key="*this">
    <view 
      class="item {{index === currentIndex ? 'active': ''}}"
      bindtap="onItemTap"
      data-index="{{index}}"
    >
      <text class="title">{{ item }}</text>
    </view>
  </block>
</view>
```

```js
// components/tab-control/tab-control.js
Component({
  properties: {
    titles: {
      type: Array,
      value: []
    }
  },

  data: {
    currentIndex: 0
  },

  methods: {
    onItemTap(event) {
      const currentIndex = event.currentTarget.dataset.index
      this.setData({ currentIndex })

      // 自定义事件
      this.triggerEvent("indexchange", currentIndex)
    },
    test(index) {
      console.log("tab control test function exec");
      this.setData({
        currentIndex: index
      })
    }
  }
})

```



```html
<!-- 4.tab-control的使用 -->
<tab-control
  class="tab-control"
  titles="{{digitalTitles}}"
  bind:indexchange="onTabIndexChange"
/>
<button bindtap="onExecTCMethod">调用TC方法</button>

<tab-control titles="{{['流行', '新款', '热门']}}"/>
```

```js
  onTabIndexChange(event) {
    const index = event.detail
    console.log("点击了", this.data.digitalTitles[index]);
  },
  onExecTCMethod() {
    // 1.获取对应的组件实例对象
    const tabControl = this.selectComponent(".tab-control")

    // 2.调用组件实例的方法
    tabControl.test(2)
  }
```



### 页面直接调用组件方法

+ vue中调用组件的方法是通过ref获取组件实例，通过.的方式调用方法

可在父组件里调用 this.selectComponent ，获取子组件的实例对象。 

+ 调用时需要传入一个匹配选择器 selector，如：this.selectComponent(".my-component")。

## 5 组件插槽定义使用

### 什么是插槽

slot翻译为插槽：  在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽。  插槽的目的是让我们原来的设备具备更多的扩展性。  比如电脑的USB我们可以插入U盘、硬盘、手机、音响、键盘、鼠标等等。 ◼ 组件的插槽：  组件的插槽也是为了让我们封装的组件更加具有扩展性。  让使用者可以决定组件内部的一些内容到底展示什么。 ◼ 栗子：移动网站中的导航栏。  移动开发中，几乎每个页面都有导航栏。  导航栏我们必然会封装成一个插件，比如nav-bar组件。  一旦有了这个组件，我们就可以在多个页面中复用了。

### 单个插槽的使用

除了内容和样式可能由外界决定之外，也可能外界想决定显示的方式  比如我们有一个组件定义了头部和尾部，但是中间的内容可能是一段文字，也可能是一张图片，或者是一个进 度条。  在不确定外界想插入什么其他组件的前提下，我们可以在组件内预留插槽：

### behaviors

behaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins”。  每个 behavior 可以包含一组属性、数据、生命周期函数和方法；  组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用；  每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior ；

### 多个插槽的使用

## 6 Component构造器

### 组件的生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。 

+ 其中，最重要的生命周期是 created attached detached ，包含一个组件实例生命流程的最主要时间点。

自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高



![image-20240222223127747](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222223127747.png)

```JS
// components/c-lifetime/c-lifetime.js
Component({
  // 组件本身的生命周期
  lifetimes: {
    created() {
      console.log("组件被创建created");
    },
    attached() {
      console.log("组件被添加到组件树中attached");
    },
    detached() {
      console.log("组件从组件树中被移除detached");
    }
  },
  // 在组件内监听页面中的生命周期
  pageLifetimes: {
    show() {
      console.log("page show");
    },
    hide() {
      console.log("page hide");
    }
  }
})

```



### 组件所在页面的生命周期

还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。

+ 样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。

其中可用的生命周期包括：

| 生命周期  | 参数          | 描述                           | 最低版本                                                     |
| :-------- | :------------ | :----------------------------- | :----------------------------------------------------------- |
| show      | 无            | 组件所在的页面被展示时执行     | [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hide      | 无            | 组件所在的页面被隐藏时执行     | [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| resize    | `Object Size` | 组件所在的页面尺寸变化时执行   | [2.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| routeDone | 无            | 组件所在页面路由动画完成时执行 | [2.31.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

![image-20240222223343992](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222223343992.png)



![image-20240222223605053](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240222223605053.png)



# day06 小程序系统API调用

## 1 网络请求API和封装 

### 网络请求 – API参数

微信提供了专属的API接口,用于网络请求: wx.request(Object object)

| 属性 | 类型    | 默认值                    | 必填 | 说明 | 最低版本                                                     |                                                              |
| :--- | :------ | :------------------------ | :--- | :--- | :----------------------------------------------------------- | ------------------------------------------------------------ |
|      | url     | string                    |      | 是   | 开发者服务器接口地址                                         |                                                              |
|      | data    | string/object/ArrayBuffer |      | 否   | 请求的参数                                                   |                                                              |
|      | header  | Object                    |      | 否   | 设置请求的 header，header 中不能设置 Referer。 `content-type` 默认为 `application/json` |                                                              |
|      | timeout | number                    |      | 否   | 超时时间，单位为毫秒。默认值为 60000                         | [2.10.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
|      | method  | string                    | GET  | 否   | HTTP 请求方法                                                |                                                              |



### 网络请求域名配置

每个微信小程序需要事先设置通讯域名，小程序只可以跟指定的域名进行网络通信。 

+ 小程序登录后台 – 开发管理 – 开发设置 – 服务器域名；

 服务器域名请在 「小程序后台 - 开发 - 开发设置 - 服务器域名」 中进行配置，配置时需要注意：

+ 域名只支持 https (wx.request、wx.uploadFile、wx.downloadFile) 和 wss (wx.connectSocket) 协议； 
+ 域名不能使用 IP 地址（小程序的局域网 IP 除外）或 localhost； 
+ 可以配置端口，如 https://myserver.com:8080，但是配置后只能向 https://myserver.com:8080 发起请求。如果向 https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
+ 如果不配置端口。如 https://myserver.com，那么请求的 URL 中也不能包含端口，甚至是默认的 443 端口也不可以。如果 向 https://myserver.com:443 请求则会失败。 
+ 域名必须经过 ICP 备案； 
+ 出于安全考虑，api.weixin.qq.com 不能被配置为服务器域名，相关 API 也不能在小程序内调用。 开发者应将 AppSecret 保存到后台服务器中，通过服务器使用 getAccessToken 接口获取 access_token，并调用相关 API； 
+ 不支持配置父域名，使用子域名。

## 2 展示弹窗和页面分享 

## 3 设备信息和位置信息 

## 4 小程序Storage存储

## 5 页面跳转和数据传递

## 6 小程序登录流程演练