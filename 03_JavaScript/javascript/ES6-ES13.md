# ES6~ES13新特性

## 1 ECMA新描述概念

### 新的ECMA代码执行描述

在执行学习JavaScript代码执行过程中，我们学习了很多ECMA文档的术语：

+ **执行上下文栈**：Execution Context Stack，用于执行上下文的栈结构
+ **执行上下文**：Execution Context，代码在执行之前会创建对应的执行上下文
+ **变量对象**：Variable Object，上下文关联的VO对象，用于记录函数和变量声明
+ **全局对象**：Global Object，全局执行上下文关联的VO对象
+ **激活对象**：Activation Object，函数执行上下文关联的VO对象
+ **作用域链**：scope chain，作用域链，用于关联指向上下的变量查找

在新的ECMA代码执行描述中（ES5以及之上），对于代码的执行流程描述改成了另外的一些词汇： 

+ 基本思路是相同的，只是对于一些词汇的描述发生了改变； 
+ **执行上下文栈和执行上下文**也是相同的；



> + 作用域链：在我们执行的过程中，访问到一个变量时，优先会在自己的VO作用域下查找，没有的话，会沿着作用域链一层层的查找
> + 执行上下文会关联一个此法环境，此法环境中会存在环境记录，outer记录外层的词法环境



### 词法环境（Lexical Environments）

词法环境是一种规范类型，用于**在词法嵌套结构中定义关联的变量、函数等标识符**

+ 一个词法环境是由**环境记录（Environment Record）**和一个**外部词法环境（oute;r Lexical Environment）**组成
+ 一个词法环境经常用于**关联一个函数声明、代码块语句、try-catch语句**，当它们的**代码被执行时，词法环境也被创建出来**



### LexicalEnvironment和VariableEnvironment

+ LexicalEnvironment用于**处理let、const声明的标识符**：
+ VariableEnvironment用于**处理var和function声明的标识符**

> + 一个执行上下文会关联两个词法环境，在真正赋值之前是不允许访问的，不能进行作用域提升，暂时性死区
> + let会记录其状态，是否有被初始化



### 环境记录（Environment Record）

 在这个规范中有两种主要的环境记录值:声明式环境记录和对象环境记录。 

+ 声明式环境记录：声明性环境记录用于定义ECMAScript语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定与 ECMAScript语言值关联起来的Catch子句。 
+ 对象式环境记录：对象环境记录用于定义ECMAScript元素的效果，例如WithStatement，它将标识符绑定与某些对象的属性 关联起来。

### 新ECMA描述内存图



## 2 let、const的使用

### let/const基本使用

let关键字： 

+ 从直观的角度来说，let和var是没有太大的区别的，都是用于声明一个变量； 

 const关键字： 

+ const关键字是constant的单词的缩写，表示**常量、衡量的意思；** 
+ 它表示**保存的数据一旦被赋值，就不能被修改**； 
+ 但是如果赋值的是引用类型，那么可以**通过引用找到对应的对象，修改对象的内容；**

注意：

+ 另外**let、const不允许重复声明变量**；



#### let/const作用域提升

+ var声明的变量是会进行作用域提升的；
+ 但是如果我们使用let声明的变量，在声明之前访问会报错

那么是不是意味着foo变量只有在代码执行阶段才会创建的呢？

+ 事实上并不是这样的，我们可以看一下ECMA262对let和const的描述

+ 这些变量会被创建在包含他们的词法环境被实例化时，但是是不可以访问它们的，直到词法绑定被求值；

### 暂时性死区 (TDZ)

在let、const定义的标识符真正执行到声明的代码之前，是不能被访问的

+ 从**块级作用域的顶部一直到变量声明完成之前**，这个变量处在**暂时性死区（TDZ，temporal dead zone）**
+ 使用术语 “temporal” 是因为**区域取决于执行顺序（时间）**，而不是编写代码的位置；

> 从作用域开始，到变量被定义之前



### let/const有没有作用域提升呢？

 从上面我们可以看出，在**执行上下文的词法环境创建出来的时候**，**变量事实上已经被创建**了，只是**这个变量是不能被访问的**。 

+ 那么变量已经有了，但是不能被访问，是不是一种作用域的提升呢？ 

事实上维基百科并没有对作用域提升有严格的概念解释，那么我们自己从字面量上理解； 

+ **作用域提升**：在**声明变量的作用域中**，如果**这个变量可以在声明之前被访问，那么我们可以称之为作用域提升**； 
+ 在这里，它虽然被创建出来了，但是不能被访问，我认为不能称之为作用域提升； 

所以我的观点是**let、const没有进行作用域提升，但是会在解析阶段被创建出来**。

> 当变量包含的词法环境被创建时，这个变量就被创建了，但是不允许访问，直到被词法绑定赋值，并不是代码指向到这一行的时候这个变量才被创建出来



### Window对象添加属性

在全局通过var来声明一个变量，事实上会在window上添加一个属性

+ 但是let、const是不会给window上添加任何属性的。

## 3 let、const和var的区别

 

## 4 块级作用域的使用

### var的块级作用域

+ JavaScript只会形成两个作用域：全局作用域和函数作用域。
+ ES5中放到一个代码中定义的变量，外面是可以访问的：

### let/const的块级作用域

+ 在ES6中新增了块级作用域，并且通过let、const、function、class声明的标识符是具备块级作用域的限制的：
+ 但是我们会发现函数拥有块级作用域，但是外面依然是可以访问的： 
  + 这是因为引擎会对函数的声明进行特殊的处理，允许像var那样进行提升；



### 块级作用域的应用



## 5 模板字符串的详解

### 字符串模板基本使用

在ES6之前，如果我们想要将字符串和一些动态的变量（标识符）拼接到一起，是非常麻烦和丑陋的（ugly）。 

ES6允许我们使用字符串模板来嵌入JS的变量或者表达式来进行拼接： 

+ 首先，我们会使用 `` 符号来编写字符串，称之为模板字符串； 
+ 其次，在模板字符串中，我们可以通过 ${expression} 来嵌入动态的内容；、



### 标签模板字符串使用

模板字符串还有另外一种用法：标签模板字符串（Tagged Template Literals）。

如果我们使用标签模板字符串，并且在调用的时候插入其他的变量： 

+ **模板字符串被拆分**了； 
+ 第一个元素是**数组**，是**被模块字符串拆分的字符串组合**； 
+ **后面的元素是一个个模块字符串传入的内容**；



## 6 ES6函数的增强用法