# JavaScript函数的增强知识

## 1 函数属性和arguments

### 1.1 函数对象的属性

JavaScript中函数也是一个对象,那么对象中就可以有属性和方法

+ **属性name**：一个函数的名词我们可以通过name来访问；

```js
      function foo(a, b, c) {}
      var bar = function (m, n, ...others) {};

      // 自定义属性
      foo.message = "tjj";
      console.log(foo.message);

      // 默认函数对象中已经有自己的属性
      console.log(foo.name);
      console.log(bar.name);
      /*
        tjj
        foo
        bar
      */
```



+ **属性length**：属性length用于返回函数参数的个数； 
  + 注意：rest参数是不参与参数的个数的(有默认值的参数是不算在length中)；

```js
      function foo(a, b, c) {}
      var bar = function (m, n = 20, ...others) {};

      // length参数的个数
      function test() {}
      test(111, 222, 333);

      console.log(foo.length);
      console.log(bar.length);
      console.log(test.length);

      /*
        3
        1
        0
      */
```



### 1.2 认识arguments

**arguments**是一个对应于**传递给函数的参数**的**类数组(array-like)对象**

```js
      function foo(m, n) {
        // 虽然不是数组，但是可以进行遍历遍历
        for (var i = 0; i < arguments.length; i++) {
          console.log(arguments[i]);
        }
        for (var arg of arguments) {
          console.log(arg);
        }
      }
      foo(10, 20, 30, 40);
```



array-like意味着它不是一个数组类型，而是一个**对象类型**： 

+ 但是它却拥有数组的一些特性，比如说length，比如可以通过index索引来访问； 

```js
      function foo(m, n) {
        // 1.默认用法
        // 通过索引获取内容
        console.log(arguments[0]);
        console.log(arguments[1]);
        console.log(arguments.length); 
      }
      foo(10, 20, 30, 40);
```

+ 但是它却没有数组的一些方法，比如filter、map等；

```js
      function foo(m, n) {
        // 2.需求获取所有参数中的偶数
        // 数组 filter
        for (var arg of arguments) {
          if (arg % 2 === 0) {
            console.log(arg);
          }
        }
        // 不能使用数组中的一些方法
        var evenNumber = arguments.filters((item) => item % 2 === 0);
        console.log(eventNums); //报错
      }
      foo(10, 25, 32, 41);
```

#### 转化方式一：

遍历arguments，添加到一个新数组中；

```js
function foo(m, n) {
        // 2.1.将arguments转成数组方式一:
        var newArguments = [];
        for (var arg of arguments) {
          newArguments.push(arg);
        }
        console.log(newArguments);
      }
      foo(10, 25, 32, 41);
```



#### 转化方式二：

```js
      function foo(m, n) {
        // 2.3.将arguments转成数组方式二: 调用slice方法
        // slice()返回数组中被选中的元素[n,m)，若参数为0则选中数组中的所有元素返回
        /*
          slice.apply(arguments);相当于nums.slice()
          一个是显示绑定this，一个是隐式绑定
          因为是实例方法所以[]数组实例去调用，如果是类方法则采用Array
        */
        var newArgs = [].slice.apply(arguments);
        // var newArgs = Array.prototype.slice.apply(arguments)
        console.log(newArgs);
      }
      foo(10, 25, 32, 41);
```



#### 转化方式三：ES6中的两个方法

+ Array.from
  + Array.from()静态方法从**可迭代**或**类数组对象**创建一个新的浅拷贝的数组实例。
+ […arguments]

```js
      function foo(m, n) {
        // 2.2.将arguments转成数组方式三: ES6中方式
        var newArgs1 = Array.from(arguments);
        console.log(newArgs);
        var newArgs2 = [...arguments];
        console.log(newArgs);
      }
      foo(10, 25, 32, 41);
```

### 1.3 箭头函数的arguments

+ 箭头函数不绑定arguments，若要执行argument会向外层作用域查找

```js
      // 1.箭头函数不绑定arguments
      var bar = () => {
        console.log(arguments);
      };

      // bar(11, 22, 33);

      // 2.函数的嵌套箭头函数
      function foo() {
        var bar = () => {
          console.log(arguments);
        };
        bar(5);
      }

      foo(111, 222);
```



### 1.3 函数的剩余（rest）参数

**ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中：**

+ 如果最后一个参数是...为前缀的，那么它会将剩余的参数放到该参数中

```js
// 剩余参数：rest parameters
      function foo(num1, num2, ...otherNums) {
        console.log(otherNums);
      }
      foo(20, 30, 111, 222, 333);

      // 默认一个函数只有剩余参数
      function bar(...args) {
        console.log(args);
      }

      bar("abc", 123, "cba", 321);
```





**剩余参数和arguments的区别**

+ 剩余参数只包含那些**没有对应形参的实参**，而**arguments对象包含了传给函数的所有实参**
+ arguments对象不是一个真正的数组，而rest参数是一个真正的数组，可以进行数组的所有操作
+  arguments是早期的**ECMAScript**中为了方便去获取所有的参数提供的一个数据结构，而rest参数是**ES6**中提供并且希望以此 来替代arguments的；



**剩余参数必须放到最后一个位置，否则会报错**



## 2 纯函数的理解和应用

函数式编程中有一个非常重要的概念叫**纯函数**，JavaScript符合函数式编程的范式，所以也有纯函数的概念

+ 在**react开发中纯函数是被多次提及**的； 
+ 比如**react中组件就被要求像是一个纯函数**（为什么是像，因为还有class组件），**redux中有一个reducer的概念**，也是要求 必须是一个纯函数； 
+ 所以**掌握纯函数对于理解很多框架的设计**是非常有帮助的；

纯函数的维基百科定义： 

+ 在程序设计中，若一个函数**符合以下条件**，那么这个函数被称为纯函数：
+ 此函数在相同的输入值时，需产生相同的输出
+ 函数的输出和输入值意外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关
+ 该函数不能由语义上可观察的函数副作用，诸如”触发事件“，使输出设备输出，或更改输出值以外物件的内容等

总结

+ **确定的输入，一定会产生确定的输出**
+ **函数在执行过程中，不能产生副作用**



## 3 柯里化的理解和应用



## 4 组合函数理解和应用



## 5 with、eval的使用



## 6 严格模式的使用