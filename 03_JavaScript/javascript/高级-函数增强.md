# JavaScript函数的增强知识

## 1 函数属性和arguments

### 1.1 函数对象的属性

JavaScript中函数也是一个对象,那么对象中就可以有属性和方法

+ **属性name**：一个函数的名词我们可以通过name来访问；

```js
      function foo(a, b, c) {}
      var bar = function (m, n, ...others) {};

      // 自定义属性
      foo.message = "tjj";
      console.log(foo.message);

      // 默认函数对象中已经有自己的属性
      console.log(foo.name);
      console.log(bar.name);
      /*
        tjj
        foo
        bar
      */
```



+ **属性length**：属性length用于返回**函数参数的个数**； 
  + 注意：**rest参数是不参与参数的个数的**(有默认值的参数是不算在length中)；

```js
      function foo(a, b, c) {}
      var bar = function (m, n = 20, ...others) {};

      // length参数的个数
      function test() {}
      test(111, 222, 333);

      console.log(foo.length);
      console.log(bar.length);
      console.log(test.length);

      /*
        3
        1
        0
      */
```



### 1.2 认识arguments

**arguments**是一个对应于**传递给函数的参数**的**类数组(array-like)对象**

```js
      function foo(m, n) {
        // 虽然不是数组，但是可以进行遍历遍历
        for (var i = 0; i < arguments.length; i++) {
          console.log(arguments[i]);
        }
        for (var arg of arguments) {
          console.log(arg);
        }
      }
      foo(10, 20, 30, 40);
```



array-like意味着它不是一个数组类型，而是一个**对象类型**： 

+ 但是它却拥有数组的一些特性，比如说length，比如可以通过index索引来访问； 

```js
      function foo(m, n) {
        // 1.默认用法
        // 通过索引获取内容
        console.log(arguments[0]);
        console.log(arguments[1]);
        console.log(arguments.length); 
      }
      foo(10, 20, 30, 40);
```

+ 但是它却没有数组的一些方法，比如filter、map等；

```js
      function foo(m, n) {
        // 2.需求获取所有参数中的偶数
        // 数组 filter
        for (var arg of arguments) {
          if (arg % 2 === 0) {
            console.log(arg);
          }
        }
        // 不能使用数组中的一些方法
        var evenNumber = arguments.filters((item) => item % 2 === 0);
        console.log(eventNums); //报错
      }
      foo(10, 25, 32, 41);
```

### 1.3 arguments转Array

+ 在开发中，我们经常需要将arguments转成Array，以便使用数组的一些特性

#### 转化方式一：

+ 遍历arguments，添加到一个新数组中；

```js
     function foo(m, n) {
        // 2.1.将arguments转成数组方式一:
        var newArguments = [];
        for (var arg of arguments) {
          newArguments.push(arg);
        }
        console.log(newArguments);
      }
      foo(10, 25, 32, 41);
```



#### 转化方式二：

+ 调用数组slice函数的call方法；

```js
      function foo(m, n) {
        // 2.3.将arguments转成数组方式二: 调用slice方法
        // slice()返回数组中被选中的元素[n,m)，若参数为0则选中数组中的所有元素返回
        /*
          slice.apply(arguments);相当于nums.slice()
          一个是显示绑定this，一个是隐式绑定
          因为是实例方法所以[]数组实例去调用，如果是类方法则采用Array
        */
        var newArgs = [].slice.apply(arguments);
        // var newArgs = Array.prototype.slice.apply(arguments)
        console.log(newArgs);
      }
      foo(10, 25, 32, 41);
```



#### 转化方式三：ES6中的两个方法

+ Array.from
  + Array.from()静态方法从**可迭代**或**类数组对象**创建一个新的浅拷贝的数组实例。
  + […arguments]剩余参数

```js
      function foo(m, n) {
        // 2.2.将arguments转成数组方式三: ES6中方式
        var newArgs1 = Array.from(arguments);
        console.log(newArgs);
        var newArgs2 = [...arguments];
        console.log(newArgs);
      }
      foo(10, 25, 32, 41);
```



### 1.4 箭头函数的arguments

+ 箭头函数是不绑定arguments的，所以我们在箭头函数中使用arguments会去**上层作用域查找**

```js
      // 1.箭头函数不绑定arguments
      var bar = () => {
        console.log(arguments);
      };

      // bar(11, 22, 33);

      // 2.函数的嵌套箭头函数
      function foo() {
        var bar = () => {
          console.log(arguments);
        };
        bar(5);
      }

      foo(111, 222);
```



### 1.5 函数的剩余（rest）参数

**ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中：**

+ 如果最后一个参数是...为前缀的，那么它会将剩余的参数放到该参数中

```js
// 剩余参数：rest parameters
      function foo(num1, num2, ...otherNums) {
        console.log(otherNums);
      }
      foo(20, 30, 111, 222, 333);

      // 默认一个函数只有剩余参数
      function bar(...args) {
        console.log(args);
      }

      bar("abc", 123, "cba", 321);
```



**剩余参数和arguments的区别**

+ 剩余参数只包含那些**没有对应形参的实参**，而**arguments对象包含了传给函数的所有实参**
+ **arguments对象不是一个真正的数组**，而**rest参数是一个真正的数组**，可以进行数组的所有操作
+  arguments是早期的**ECMAScript**中为了方便去获取所有的参数提供的一个数据结构，而rest参数是**ES6**中提供并且希望以此 来替代arguments的；

**剩余参数必须放到最后一个位置，否则会报错**



## 2 纯函数的理解和应用

函数式编程中有一个非常重要的概念叫**纯函数**，JavaScript符合函数式编程的范式，所以也有纯函数的概念

+ 在**react开发中纯函数是被多次提及**的； 
+ 比如**react中组件就被要求像是一个纯函数**（为什么是像，因为还有class组件），**redux中有一个reducer的概念**，也是要求 必须是一个纯函数； 
+ 所以**掌握纯函数对于理解很多框架的设计**是非常有帮助的；



### 2.1 纯函数的维基百科定义

+ 在程序设计中，若一个函数**符合以下条件**，那么这个函数被称为纯函数：
+ 此函数**在相同的输入值时**，需**产生相同的输出**
+ 函数的输出和输入值以外的其他隐藏信息或状态无关，也和**由I/O设备产生的外部输出**无关
+ 该函数**不能由语义上可观察的函数副作用**，诸如**”触发事件“**，**使输出设备输出，或更改输出值以外物件的内容**等

总结

+ **确定的输入，一定会产生确定的输出**
+ **函数在执行过程中，不能产生副作用**

![image-20240109231728290](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20240109231728290.png)



### 2.2 副作用概念的理解

在计算机科学中，也引用了副作用的概念，表示在**执行一个函数时**，除了**返回函数值**之外，还对**调用函数产生了附加的影响**， 比如**修改了全局变量，修改参数或者改变外部的存储**；

纯函数在执行的过程中就是不能产生这样的副作用： 

+ 副作用往往是产生**bug的 “温床”**

```js
      var names = ["abc", "cba", "nba", "mba"]

      // 1.slice: 纯函数
      var newNames = [].slice.apply(names,[1,3])
      var newNames = names.slice(1,3)
      console.log(names)
```

### 2.3 纯函数的案例

+ **slice**：slice截取数组时不会对原数组进行任何操作,而是生成一个新的数组；
+  **splice**：splice截取数组, 会返回一个新的数组, 也会对原数组进行修改；

```js
	  var names = ["abc", "cba", "nba", "mba"]

      // 1.slice: 纯函数
      var newNames = [].slice.apply(names,[1,3])
      var newNames = names.slice(1,3)
      console.log(names)

      // 2.splice: 操作数组的利器(不是纯函数)
      names.splice(2.2)
      console.log(names) //原数组会被修改
```



### 2.4 纯函数的作用和优势

1. 因为你可以安心的编写和安心的使用；
2. 你在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的 外部变量是否已经发生了修改；
3. 你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出；

React中就要求我们无论是**函数还是class声明一个组件**，这个组件都必须像**纯函数一样**，**保护它们的props不被修改**

```js
// 1.安心的写: 你不需要去关心外层作用域中的值, 目前是什么状态
    var counter = 0

    function add(num) {
      return num
    }

    // 2.安心的用: 调用函数时, 可以知道: 确定的输入一定产生确定的输出
    add(5) // 10
    add(5) // 10


    // react中编写函数组件
    function Foo(props) {
      console.log(props.name)
      props.name = "kobe"
    }
```



## 3 柯里化的理解和应用

柯里化也是属于函数式编程里面一个非常重要的概念

+ 是一种关于函数的高阶技术
+ 它不仅被用于 JavaScript，还被用于其他编程语言；

### 维基百科的解释

+ 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化；
+ 是把接收**多个参数的函数**，变成**接受一个单一参数**（最初函数的第一个参数）的函数，并且**返回接剩下的参数**，而且**返回结果的新函数的技术**
+ 柯里化声称 **"如果你固定某些参数，你将得到接受余下参数的一个函数"**



总结

+ 只**传递给函数一部分参数来调用它**，让**它返回一个函数去处理剩余的函数**
+ **这个过程就称之为柯里化**

柯里化是一种函数的转换，将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。 

+ 柯里化不会调用函数。它只是对函数进行转换。



### 柯里化优势一 - 函数的职责单一

柯里化的原因

+ 在函数式编程中，往往希望**一个函数处理的问题尽可能的单一**，而**不是将一大堆的处理过程交给一个函数来处理**
+ 那么**我们是否就可以将每次传入的参数在单一的函数中进行处理**，处理完后在**下一个函数中再使用处理后的结果；**

比如上面的案例我们进行一个修改：**传入的函数需要分别被进行如下处理**

+ 第一个参数 + 2 
+ 第二个参数 * 2 
+ 第三个参数 ** 2



### 柯里化优势二 - 函数的参数服用

另外一个使用柯里化的场景是可以帮助我们可以**复用参数逻辑**： 

+ makeAdder函数要求我们传入一个num（并且如果我们需要的话，可以在这里对num进行一些修改）； 
+ 在之后使用返回的函数时，我们不需要再继续传入num了



### 柯里化案例练习

这里我们在演示一个案例，需求是打印一些日志： 

+ 日志包括时间、类型、信息；

普通函数的实现方案如下：

### 柯里化高级 - 自动柯里化函数

目前我们有将多个普通的函数，转成柯里化函数：

## 4 组合函数理解和应用

### 组合函数概念的理解

组合（Compose）函数是在JavaScript开发过程中一种对**函数的使用技巧、模式**

+ 比如现在需要对**某一数据**进行**函数的调用**，执行**两个函数fn1和fn2**，这**两个函数是依次执行**的
+ 如果每次我们都需要**进行两个函数的调用，操作上就会显得重复**；
+ 那么**是否可以将这两个函数组合起来，自动依次调用**呢？
+ 这个过程就是对函数的组合，我们称之为 **组合函数（Compose Function）**；



### 实现组合函数

刚才我们实现的compose函数比较简单 

我们需要考虑更加复杂的情况：比如传入了更多的函数，在调用compose函数时，传入了更多的参数：

## 5 with、eval的使用

### with语句的使用

+ with语句 扩展一个语句的作用域链。
+  不建议使用with语句，因为它可能是混淆错误和兼容性问题的根源。



### eval函数

**内建函数 eval 允许执行一个代码字符串**。 

+ **eval是一个特殊的函数**，它可以**将传入的字符串当做JavaScript代码来运行**； 
+ **eval会将最后一句执行语句的结果，作为返回值；**



不建议在开发中使用eval： 

+ eval代码的**可读性非常的差**（代码的可读性是高质量代码的重要原则）； 
+ eval是**一个字符串**，那么有可能在**执行的过程中被刻意篡改，那么可能会造成被攻击的风险；** 
+ eval的执行**必须经过JavaScript解释器，不能被JavaScript引擎优化**；

## 6 严格模式的使用

### 认识严格模式

JavaScript历史的局限性： 

+ 长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题； 
+ 新的特性被加入，旧的功能也没有改变，这么做有利于兼容旧代码； 
+ 但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中； 

在ECMAScript5标准中，JavaScript提出了严格模式的概念（Strict Mode）： 

+ 严格模式很好理解，是一种具有限制性的JavaScript模式，从而使代码隐式的脱离了 ”懒散（sloppy）模式“； 
+ 支持严格模式的浏览器在检测到代码中有严格模式时，会以更加严格的方式对代码进行检测和执行； 

严格模式对正常的JavaScript语义进行了一些限制： 

+ 严格模式通过 抛出错误 来消除一些原有的 静默（silent）错误； 
+ 严格模式让JS引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）； 
+ 严格模式禁用了在ECMAScript未来版本中可能会定义的一些语法；





### 开启严格模式





### 严格模式限制