# JavaScript ES5中实现继承

## 1 对象和函数的原型

### 1.1 认识对象的原型

**JavaScript当中每个对象都有一个特殊的内置属性[[prototype]]（但在调用时属性名为`__proto__`），这个特殊的对象可以指向另外一个对象**

那么这个对象有什么用呢？

+ 当我们通过引用对象的属性**key来获取一个value时**，他会出发get的操作
+ 这个操作**首先会检查该对象是否有对应的属性**，如果有的话就使用它
+ **如果对象中没有改属性，那么会访问对象prototype内置属性指向的对象上的属性**

```js
      var obj = {
        name: "why",
        age: 18,
      };

      // 当我们通过[[get]]方式获取一个属性对应的value时
      // 1.它会优先在自己对象中查找，如果找到直接返回
      // 2.如果没有找到，那么会在原型对象中找
      obj.__proto__.message = "tjj";
      console.log(obj.message);
```

+ 输出：tjj



那么如果通过字面量直接创建一个对象，这个对象也会有这样的属性吗？如果有，应该如何获取这个属性呢？ 

+ 答案是有的，只要是对象都会有这样的一个内置属性



获取的方式有两种：

+ 方式一：通过**对象的_proto__属性**可以获取到（但是这个是早期**浏览器自己添加的**，存在一定的兼容性问题）
+ 方式二：通过 **Object.getPrototypeOf 方法**可以获取到；

```js
      var obj = {
        name: "why",
        age: 18,
      };
      console.log(obj);
      console.log(obj.name, obj.age);

      // 获取对象的原型
      // 方式一：__proto__
      console.log(obj.__proto__.__proto__);
      // 方式二：Object.getPrototypeOf()方法
      console.log(Object.getPrototypeOf(obj));
      console.log(obj.__proto__ === Object.getPrototypeOf(obj));
```



### 1.2 函数的原型 prototype

对象的原型对于构造函数创建对象的作用？

+ 用来构建对象时，给它设置隐式原型的

所有的函数都有一个prototype的属性（注意：不是__proto__）

因为是一个函数，才有了prototype这个属性，而不是因为函数是一个对象

```js
      var obj = {};
      function foo() {}

      // 1.将函数看成一个普通对象时，它是具备__proto__（隐式对象）
      // 作用：查找key对应的value时，会找到原型身上
      console.log(obj.__proto__);
      console.log(foo.__proto__);

      // 2.将函数看成一个函数时，它具备prototype（显示原型）
      // 作用：用来构建对象时，给他设置隐式原型的
      console.log(foo.prototype);
      // console.log(obj.prototype) 对象是没有prototype
```



## 2 new、constructor

### 2.1 new操作符

new关键字的步骤如下：

1. 在内存中创建一个新的对象（空对象）
2. **这个对象内部的[[prototype]]属性**会被赋值为**该构造函数的prototype属性**

那么也就意味着我们通过Person构造函数创建出来的所有对象的[[prototype]]属性都指向Person.prototype：

```js
      var f1 = new Foo();
      /*
        相当于执行了如下操作:
        f1 = {}
        f1.__proto__ = Foo.prototype
      */
```



```js
      function Foo() {
        // 1.创建空的对象
        // 2.将Foo的prototype原型（显式原型）赋值给空的对象的__proto__（隐式原型）
      }

      console.log(Foo.prototype);
      var f1 = new Foo();
      var f2 = new Foo();
      var f3 = new Foo();
      var f4 = new Foo();
      var f5 = new Foo();

      console.log(f1.__proto__);
      console.log(f2.__proto__ === Foo.prototype);
      console.log(f3.__proto__ === f5.__proto__);
```

+ 最后相等运算符是输出true



#### 2.1.1 函数(显示)原型的作用

将构造函数的方法放在原型上，防止创建很多个函数对象

```js
      /*
      1.什么是函数的显示原型
        * 区分和对象原型的区别
      2.函数原型的作用
        * 在通过new操作符创建对象时，将这个显式原型赋值给创建出来对象的隐式原型
      3.案例Person，将所有的函数定义放到了显式原型上
      */

      function Student(name, age, sno) {
        this.name = name;
        this.age = age;
        this.sno = sno;

        // 1.方式一: 编写函数, 会创建很多个函数对象
        // this.running = function() {
        //   console.log(this.name + " running")
        // }
        // this.eating = function() {
        //   console.log(this.name + " eating")
        // }
        // this.studying = function() {
        //   console.log(this.name + " studying")
        // }
      }

      Student.prototype.running = function () {
        console.log(this.name + " running");
      };
      Student.prototype.eating = function () {
        console.log(this.name + " eating");
      };

      // 当我们多个对象拥有共同的值时，我们可以将它放到构造函数对象的显式原型
      // 由构造函数创建出来的所有对象，都会共享这些属性

      // 1.创建三个学生
      var stu1 = new Student("why", 18, 111);
      var stu2 = new Student("kobe", 30, 112);
      var stu3 = new Student("james", 18, 111);

      stu1.running();
      stu2.eating();
```



### 2.2 创建对象的内存表现



### 2.3 prototype添加属性



### 2.4 constructor属性

事实上**原型对象上面是有一个属性的：constructor**

+ 默认情况下原型上都会添加一个属性叫做constructor，这个**constructor指向当前的函数对象；**

```js
// 非常重要的属性：constructor，指向Person函数对象
      function Person() {}

      var PersonPrototype = Person.prototype;
      console.log(PersonPrototype);
      console.log(PersonPrototype.constructor); //输出：ƒ Person() {}
      console.log(PersonPrototype.constructor === Person); //true

      // 2.实例对象p
      var p = new Person();
      console.log(p.__proto__.constructor.name); //函数自带属性name，输出：Person
      console.log(p.__proto__.constructor === Person);
```





### 2.5 重写原型对象

如果我们需要在原型上添加过多的属性，通常我们会重写整个原型对象：

前面我们说过, 每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性； 

+ 而我们这里相当于给prototype重新赋值了一个对象, 那么这个新对象的constructor属性, 会指向Object构造函数, 而不是 Person构造函数了

```js
    function Person() {

    }

    console.log(Person.prototype)
    
    // 在原有的原型对象上添加新的属性
    // Person.prototype.message = "Hello Person"
    // Person.prototype.info = { name: "哈哈哈", age: 30 }
    // Person.prototype.running = function() {}
    // Person.prototype.eating = function() {}

    // console.log(Person.prototype)
    // console.log(Object.keys(Person.prototype))

    // 直接赋值一个新的原型对象
    Person.prototype = {
      message: "Hello Person",
      info: { name: "哈哈哈", age: 30 },
      running: function() {},
      eating: function() {},
      // constructor: Person
    }
    Object.defineProperty(Person.prototype, "constructor", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: Person
    })

    console.log(Object.keys(Person.prototype))

    // 新建实例对象
    var p1 = new Person()
    console.log(p1.message)
```





### 2.6 原型对象的constructor

如果希望constructor指向Person，那么可以手动添加： 

上面的方式虽然可以, 但是也会造成constructor的[[Enumerable]]特性被设置了true. 

+ 默认情况下, 原生的constructor属性是不可枚举的. 
+ 如果希望解决这个问题, 就可以使用我们前面介绍的Object.defineProperty()函数了



### 2.6 创建对象 – 构造函数和原型组合

我们在上一个构造函数的方式创建对象时，有一个弊端：会创建出重复的函数，比如running、eating这些函数 

+ 那么有没有办法让所有的对象去共享这些函数呢? 
+ 可以，将这些函数放到Person.prototype的对象上即可；

## 3 原型链的查找顺序

###  面向对象的特性 – 继承

面向对象有三大特性：封装、继承、多态 

+ 封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程； 
+ 继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中）； 
+ 多态：不同的对象在执行时表现出不同的形态；



继承的作用

+ 继承可以帮助我们**将重复的代码和逻辑抽取到父类中**，子类只需要直接继承过来使用即可； 

+ 在很多编程语言中，继承也是多态的前提；

那么JavaScript当中如何实现继承呢？

+ JavaScript原型链的机制；
+ 再利用原型链的机制实现一下继承；



```js
    // 定义Person构造函数(类)
    function Person(name, age, height, address) {
      this.name = name
      this.age = age
      this.height = height
      this.address = address
    }

    Person.prototype.running = function() {
      console.log("running~")
    }
    Person.prototype.eating = function() {
      console.log("eating~")
    }

    // 定义学生类
    function Student(name, age, height, address, sno, score) {
      this.name = name
      this.age = age
      this.height = height
      this.address = address

      this.sno = sno
      this.score = score
    }

    // 方式一: 父类的原型直接赋值给子类的原型
    // 缺点: 父类和子类共享通一个原型对象, 修改了任意一个, 另外一个也被修改
    // Student.prototype = Person.prototype

    // 方式二: 创建一个父类的实例对象(new Person()), 用这个实例对象来作为子类的原型对象
    var p = new Person("why", 18)
    Student.prototype = p

    // Student.prototype.running = function() {
    //   console.log("running~")
    // }
    // Student.prototype.eating = function() {
    //   console.log("eating~")
    // }
    Student.prototype.studying = function() {
      console.log("studying~")
    }

    // 创建学生
    var stu1 = new Student("kobe", 30, 111, 100)
    var stu2 = new Student("james", 25, 111, 100)
    stu1.running()
    stu1.studying()

    console.log(stu1.name, stu1.age)
    console.log(stu1)
    console.log(stu2.name, stu2.age)
```



### JavaScript原型链

+ 从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：

```js
// {}的本质
var info = {}
// 相当于
var info = new Object()
console.log(info.__proto__ === Object.prototype); //true
```

+ 所以意味着{}创建的对象，会将构造函数的显式原型（Object.prototype）赋值给创建新的空对象的隐式原型（`info.__proto__`）



#### 默认对象的原型链

```js
var obj = {
        name: "why",
        age: 18,
      };
      console.log(obj.messgae);
```

查找顺序

1. 在自己的对象上查找（obj），没有
2. 去obj对象的隐式原型上查找`obj.__proto__`，没找到
3. `obj.__proto__.__proto__`上查找，指向null

![image-20240112152103701](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112152103701.png)



#### 自定义原型链的内存图

+ 可以对原型进行赋值， 成为自定义原型对象
+ 相当于自定义原型链

```js
      var obj = {
        name: "why",
        age: 18,
      };

      // 对现有代码进行改造
      obj.__proto__ = {
        height: 1.88,
      };
      obj.__proto__.__proto__ = {
        message: "Hello bbbb",
      };
      console.log(obj.message);
```

![image-20240112153732108](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112153732108.png)



### Object的原型

+  从**Object直接创建出来的对象的原型**都是 [Object: null prototype] {}。

 [Object: null prototype] {} 原型有什么特殊吗？

+ 特殊一：**该对象有原型属性**，但是它的原型属性已经指向的是null，也就是已经是顶层原型了；
+ 特殊二：**该对象上有很多默认的属性和方法；**



#### 创建Object对象的内存图

![image-20240112155115666](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112155115666.png)



### Object是所有类的父类

从我们上面的Object原型我们可以得出一个结论：**原型链最顶层的原型对象就是Object的原型对象**

## 4 原型链实现的继承

+ 属性的继承和方法的继承

```js
      // 定义Person构造函数(类)
      function Person(name, age, height, address) {
        this.name = name;
        this.age = age;
        this.height = height;
        this.address = address;
      }

      Person.prototype.running = function () {
        console.log("running~");
      };
      Person.prototype.eating = function () {
        console.log("eating~");
      };

      // 定义学生类
      function Student(name, age, height, address, sno, score) {
        this.name = name;
        this.age = age;
        this.height = height;
        this.address = address;

        this.sno = sno;
        this.score = score;
      }

      Student.prototype.running = function() {
        console.log("running~")
      }
      Student.prototype.eating = function() {
        console.log("eating~")
      }
      Student.prototype.studying = function () {
        console.log("studying~");
      };
```



+ 父类的原型直接赋值给子类的原型

![image-20240112160259878](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112160259878.png)





如果我们现在需要实现继承，那么就可以利用原型链来实现了： 

+ 目前stu的原型是p对象，而p对象的原型是Person默认的原型，里面包含running等函数；
+ 注意：步骤4和步骤5不可以调整顺序，否则会有问题，即将方法添加到原有的Student显式原型对象上了，那么最后函数对象的原型指向新的对象时，这个方法就失效了

```js
      // 4.创建父类对象，并且作为子类的原型对象
      var p = new Person("why", 18, 1.88);
      Student.prototype = p;

      // 5.在子类原型上添加内容
      Student.prototype.studying = function () {
        console.log("studying~");
      };
```



+ 父类创建一个实例来作为子类的原型对象

![image-20240112162719808](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112162719808.png)



![image-20240112163038205](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112163038205.png)



+ 但是子类中的属性是不能删除的，不然只能拥有父类中的属性， 属性并没有继承过来

![image-20240112163816468](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112163816468.png)





### 原型链继承的弊端

但是目前有一个很大的弊端：某些属性其实是保存在p对象上的； 

+ 第一，我们通过**直接打印对象是看不到这个属性的**； 

```js
      // 定义学生类
      function Student(name, age, address, sno) {
        this.address = address;
        this.sno = sno;
      }

      // 4.创建父类对象，并且作为子类的原型对象
      var p = new Person("why", 18, 1.88);
      Student.prototype = p;

      // 5.在子类原型上添加内容
      Student.prototype.studying = function () {
        console.log("studying~");
      };

      // 创建学生
      var stu1 = new Student("kobe", 30, 111, 100);
      stu1.running();
      stu1.studying();

      console.log(stu1.name, stu1.age); //why 18
      console.log(stu1); //Student {address: 111, sno: 100}没有name和age属性
```



+ 第二，**这个属性会被多个对象共享**，如果这个对象是一个引用类型，那么就会造成问题；(希望每个对象都拥有自己的属性)

```js
      // 创建学生
      var stu1 = new Student("kobe", 30, 111, 100);
      var stu2 = new Student("james", 25, 111, 100);
      stu1.running();
      stu1.studying();

      console.log(stu1.name, stu1.age); //why 18
      console.log(stu2.name, stu2.age); //why 18
```

 

+ 第三，**不能给Person传递参数（让每个stu有自己的属性），因为这个对象是一次性创建的（没办法定制化）；**



## 5 借用构造函数继承



+ 一些属性在父元素中已经写过了，将对象的this传入父元素，借用父元素的构造函数来进行属性初始化

![image-20240112171752000](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20240112171752000.png)



### 组合借用继承的问题

(ES5中，ES6之前

)组合继承是JavaScript最常用的继承模式之一：

+ 如果你理解到这里, 点到为止, 那么组合来实现继承只能说问题不大； 
+ 但是它依然不是很完美，但是基本已经没有问题了；



组合继承存在什么问题呢？

+ 组合继承最大的问题就是无论在什么情况下，都会**调用两次父类构造函数**
  + 一次在**创建子类原型**的时候
  + 另一次在**子类构造函数内部借用构造函数时**（也就是每次创建子类实例的时候）
+ 另外，如果你仔细按照我的流程走了上面的每一个步骤，你会发现：**所有的子类实例事实上会拥有两份父类的属性**
  + 一份在当前的实例自己里面(也就是person本身的)，另一份在子类对应的原型对象中(也就是person.__proto__里面)； 
  + 当然，这两份属性我们无需担心访问出现问题，因为默认一定是访问实例本身这一部分的；

![image-20240112202227730](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20240112202227730.png)



### 原型式继承函数

原型式继承的渊源 

+ 这种模式要从**道格拉斯·克罗克福德**（Douglas Crockford，著名的前端大师，JSON的创立者）在2006年写的一篇文章说起: **Prototypal Inheritance in JavaScript**(在JavaScript中使用原型式继承) 
+ 在这篇文章中，它介绍了一种继承方法，而且这种继承方法不是通过构造函数来实现的. 
+ 为了理解这种方式，我们先再次回顾一下JavaScript想实现继承的目的：**重复利用另外一个对象的属性和方法.** 

最终的目的：**student对象的原型指向了person对象；**



1、用**Object.create()**方法创建新对象，并使用现有对象提供新对象的proto。

2、提供两个参数，第一个是新创建的原型对象，第二个是为新创建的对象添加属性的对象。



满足条件

1. 必须创建一个对象
2. 这个对象的隐式原型必须指向父类的显示原型
3. 将这个对象赋值给子类的显式原型



```js
      // 方案一：
      var obj = {}
      // obj.__proto__存在兼容性问题
      // obj.__proto__ = Person.prototype
      Object.setPrototypeOf(obj,Person.prototype)
      Student.prototype = obj

      // 方案二：更具通用性，既可以做Person的继承，也可以做其他类的继承
      // F不携带任何属性
      function F() {}
      F.prototype = Person.prototype
      Student.prototype = new F()

      // 方案三：Object.create可以创建一个新对象
      var obj = Object.create(Person.prototype)
      console.log(obj.__proto__ === Person.prototype); //true
      Student.prototype = obj
```



+ 担心有兼容性问题

```js
    // 工具函数
    // 创建对象的过程
    function createObject(o) {
      function F() {}
      F.prototype = o
      return new F()
    }

    // 将Subtype和Supertype联系在一起
    // 寄生式函数
    function inherit(Subtype, Supertype) {
      Subtype.prototype = createObject(Supertype.prototype)
      Object.defineProperty(Subtype.prototype, "constructor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: Subtype
      })
    }
```



+ 不担心兼容问题

```js
      // 工具函数
      function inherit(Subtype, Supertype) {
        Subtype.prototype = Object.create(Subtype.prototype)
        // 新创建出来的对象其实是作为Student函数的显式原型，而显式原型中都包含属性constructor
        Object.defineProperty(Subtype.prototype, "constructor",{
          enumerable:false,
          configurable:true,
          writable:true,
          value:Subtype
        })
      }
```



## 6 寄生组合实现继承

### 寄生式继承函数

寄生式(Parasitic)继承

+ 寄生式(Parasitic)继承是与原型式继承紧密相关的一种思想, 并且同样由道格拉斯·克罗克福德(Douglas Crockford)提出和推 广的；
+ 寄生式继承的思路是结合原型类继承和工厂模式的一种方式
+ 即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回；

+ 寄生组合式继承
+ 原型链/借用/原型式(对象之间)/寄生式函数

```js
      function inherit (subtype,supertype) {
        subtype.prototype = Object.create(supertype.prototype)
        Object.defineProperty(subtype.prototype,"constructor",{
          enumerable:false,
          configurable:true,
          writable:true,
          value:subtype
        })
      }

      function Person (name,age,height) {
        this.name = name
        this.age = age
        this.height = height
      }

      Person.prototype.running = function() {
        console.log("running");
      }
      Person.prototype.eating = function() {
        console.log("eating");
      }

      function Student (name,age,height,sno,score) {
        Person.call(this,name,age,height)
        this.sno = sno
        this.score = score
      }

      inherit(Student, Person)
      Student.prototype.studying = function () {
        console.log("studying");
      }

      var stu1 = new Student("why", 18, 1.88, 111, 100)
      var stu2 = new Student("tjj", 30, 1.98, 112, 100)
      console.log(stu1,stu2);
```



+ 寄生式继承讲的是对象之间的继承，而不是类之间的继承







