# JavaScript ES5中实现继承

## 1 对象和函数的原型

### 1.1 认识对象的原型

**JavaScript当中每个对象都有一个特殊的内置属性[[prototype]]（但在调用时属性名为`__proto__`），这个特殊的对象可以指向另外一个对象**

那么这个对象有什么用呢？

+ 当我们通过引用对象的属性**key来获取一个value时**，他会出发get的操作
+ 这个操作**首先会检查该对象是否有对应的属性**，如果有的话就使用它
+ **如果对象中没有改属性，那么会访问对象prototype内置属性指向的对象上的属性**

```js
      var obj = {
        name: "why",
        age: 18,
      };

      // 当我们通过[[get]]方式获取一个属性对应的value时
      // 1.它会优先在自己对象中查找，如果找到直接返回
      // 2.如果没有找到，那么会在原型对象中找
      obj.__proto__.message = "tjj";
      console.log(obj.message);
```

+ 输出：tjj



那么如果通过字面量直接创建一个对象，这个对象也会有这样的属性吗？如果有，应该如何获取这个属性呢？ 

+ 答案是有的，只要是对象都会有这样的一个内置属性



获取的方式有两种：

+ 方式一：通过**对象的_proto__属性**可以获取到（但是这个是早期**浏览器自己添加的**，存在一定的兼容性问题）
+ 方式二：通过 **Object.getPrototypeOf 方法**可以获取到；

```js
      var obj = {
        name: "why",
        age: 18,
      };
      console.log(obj);
      console.log(obj.name, obj.age);

      // 获取对象的原型
      // 方式一：__proto__
      console.log(obj.__proto__.__proto__);
      // 方式二：Object.getPrototypeOf()方法
      console.log(Object.getPrototypeOf(obj));
      console.log(obj.__proto__ === Object.getPrototypeOf(obj));
```



### 1.2 函数的原型 prototype

对象的原型对于构造函数创建对象的作用？

+ 用来构建对象时，给它设置隐式原型的

所有的函数都有一个prototype的属性（注意：不是__proto__）

因为是一个函数，才有了prototype这个属性，而不是因为函数是一个对象

```js
      var obj = {};
      function foo() {}

      // 1.将函数看成一个普通对象时，它是具备__proto__（隐式对象）
      // 作用：查找key对应的value时，会找到原型身上
      console.log(obj.__proto__);
      console.log(foo.__proto__);

      // 2.将函数看成一个函数时，它具备prototype（显示原型）
      // 作用：用来构建对象时，给他设置隐式原型的
      console.log(foo.prototype);
      // console.log(obj.prototype) 对象是没有prototype
```



## 2 new、constructor

### 2.1 new操作符

new关键字的步骤如下：

1. 在内存中创建一个新的对象（空对象）
2. **这个对象内部的[[prototype]]属性**会被赋值为**该构造函数的prototype属性**

那么也就意味着我们通过Person构造函数创建出来的所有对象的[[prototype]]属性都指向Person.prototype：

```js
      var f1 = new Foo();
      /*
        相当于执行了如下操作:
        f1 = {}
        f1.__proto__ = Foo.prototype
      */
```



```js
      function Foo() {
        // 1.创建空的对象
        // 2.将Foo的prototype原型（显式原型）赋值给空的对象的__proto__（隐式原型）
      }

      console.log(Foo.prototype);
      var f1 = new Foo();
      var f2 = new Foo();
      var f3 = new Foo();
      var f4 = new Foo();
      var f5 = new Foo();

      console.log(f1.__proto__);
      console.log(f2.__proto__ === Foo.prototype);
      console.log(f3.__proto__ === f5.__proto__);
```

+ 最后相等运算符是输出true



#### 2.1.1 函数(显示)原型的作用

将构造函数的方法放在原型上，防止创建很多个函数对象

```js
      /*
      1.什么是函数的显示原型
        * 区分和对象原型的区别
      2.函数原型的作用
        * 在通过new操作符创建对象时，将这个显式原型赋值给创建出来对象的隐式原型
      3.案例Person，将所有的函数定义放到了显式原型上
      */

      function Student(name, age, sno) {
        this.name = name;
        this.age = age;
        this.sno = sno;

        // 1.方式一: 编写函数, 会创建很多个函数对象
        // this.running = function() {
        //   console.log(this.name + " running")
        // }
        // this.eating = function() {
        //   console.log(this.name + " eating")
        // }
        // this.studying = function() {
        //   console.log(this.name + " studying")
        // }
      }

      Student.prototype.running = function () {
        console.log(this.name + " running");
      };
      Student.prototype.eating = function () {
        console.log(this.name + " eating");
      };

      // 当我们多个对象拥有共同的值时，我们可以将它放到构造函数对象的显式原型
      // 由构造函数创建出来的所有对象，都会共享这些属性

      // 1.创建三个学生
      var stu1 = new Student("why", 18, 111);
      var stu2 = new Student("kobe", 30, 112);
      var stu3 = new Student("james", 18, 111);

      stu1.running();
      stu2.eating();
```



### 2.2 创建对象的内存表现



### 2.3 prototype添加属性



### 2.4 constructor属性

事实上**原型对象上面是有一个属性的：constructor**

+ 默认情况下原型上都会添加一个属性叫做constructor，这个**constructor指向当前的函数对象；**

```js
// 非常重要的属性：constructor，指向Person函数对象
      function Person() {}

      var PersonPrototype = Person.prototype;
      console.log(PersonPrototype);
      console.log(PersonPrototype.constructor); //输出：ƒ Person() {}
      console.log(PersonPrototype.constructor === Person); //true

      // 2.实例对象p
      var p = new Person();
      console.log(p.__proto__.constructor.name); //函数自带属性name，输出：Person
      console.log(p.__proto__.constructor === Person);
```





### 2.5 重写原型对象

如果我们需要在原型上添加过多的属性，通常我们会重写整个原型对象：

前面我们说过, 每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性； 

+ 而我们这里相当于给prototype重新赋值了一个对象, 那么这个新对象的constructor属性, 会指向Object构造函数, 而不是 Person构造函数了

```js
    function Person() {

    }

    console.log(Person.prototype)
    
    // 在原有的原型对象上添加新的属性
    // Person.prototype.message = "Hello Person"
    // Person.prototype.info = { name: "哈哈哈", age: 30 }
    // Person.prototype.running = function() {}
    // Person.prototype.eating = function() {}

    // console.log(Person.prototype)
    // console.log(Object.keys(Person.prototype))

    // 直接赋值一个新的原型对象
    Person.prototype = {
      message: "Hello Person",
      info: { name: "哈哈哈", age: 30 },
      running: function() {},
      eating: function() {},
      // constructor: Person
    }
    Object.defineProperty(Person.prototype, "constructor", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: Person
    })

    console.log(Object.keys(Person.prototype))

    // 新建实例对象
    var p1 = new Person()
    console.log(p1.message)
```





### 2.6 原型对象的constructor

如果希望constructor指向Person，那么可以手动添加： 

上面的方式虽然可以, 但是也会造成constructor的[[Enumerable]]特性被设置了true. 

+ 默认情况下, 原生的constructor属性是不可枚举的. 
+ 如果希望解决这个问题, 就可以使用我们前面介绍的Object.defineProperty()函数了



### 2.6 创建对象 – 构造函数和原型组合

我们在上一个构造函数的方式创建对象时，有一个弊端：会创建出重复的函数，比如running、eating这些函数 

+ 那么有没有办法让所有的对象去共享这些函数呢? 
+ 可以，将这些函数放到Person.prototype的对象上即可；

## 3 原型链的查找顺序

###  面向对象的特性 – 继承

面向对象有三大特性：封装、继承、多态 

+ 封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程； 
+ 继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中）； 
+ 多态：不同的对象在执行时表现出不同的形态；



继承的作用

+ 继承可以帮助我们**将重复的代码和逻辑抽取到父类中**，子类只需要直接继承过来使用即可； 

+ 在很多编程语言中，继承也是多态的前提；

那么JavaScript当中如何实现继承呢？

+ JavaScript原型链的机制；
+ 再利用原型链的机制实现一下继承；



```js
    // 定义Person构造函数(类)
    function Person(name, age, height, address) {
      this.name = name
      this.age = age
      this.height = height
      this.address = address
    }

    Person.prototype.running = function() {
      console.log("running~")
    }
    Person.prototype.eating = function() {
      console.log("eating~")
    }

    // 定义学生类
    function Student(name, age, height, address, sno, score) {
      this.name = name
      this.age = age
      this.height = height
      this.address = address

      this.sno = sno
      this.score = score
    }

    // 方式一: 父类的原型直接赋值给子类的原型
    // 缺点: 父类和子类共享通一个原型对象, 修改了任意一个, 另外一个也被修改
    // Student.prototype = Person.prototype

    // 方式二: 创建一个父类的实例对象(new Person()), 用这个实例对象来作为子类的原型对象
    var p = new Person("why", 18)
    Student.prototype = p

    // Student.prototype.running = function() {
    //   console.log("running~")
    // }
    // Student.prototype.eating = function() {
    //   console.log("eating~")
    // }
    Student.prototype.studying = function() {
      console.log("studying~")
    }

    // 创建学生
    var stu1 = new Student("kobe", 30, 111, 100)
    var stu2 = new Student("james", 25, 111, 100)
    stu1.running()
    stu1.studying()

    console.log(stu1.name, stu1.age)
    console.log(stu1)
    console.log(stu2.name, stu2.age)
```



### JavaScript原型链

+ 从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：

### Object的原型

+  从Object直接创建出来的对象的原型都是 [Object: null prototype] {}。

 [Object: null prototype] {} 原型有什么特殊吗？

+ 特殊一：**该对象有原型属性**，但是它的原型属性已经指向的是null，也就是已经是顶层原型了；
+ 特殊二：**该对象上有很多默认的属性和方法；**



### Object是所有类的父类

从我们上面的Object原型我们可以得出一个结论：**原型链最顶层的原型对象就是Object的原型对象**

## 4 原型链实现的继承

如果我们现在需要实现继承，那么就可以利用原型链来实现了： 

+ 目前stu的原型是p对象，而p对象的原型是Person默认的原型，里面包含running等函数；
+ 注意：步骤4和步骤5不可以调整顺序，否则会有问题

### 原型链继承的弊端

但是目前有一个很大的弊端：某些属性其实是保存在p对象上的； 

+ 第一，我们通过直接打印对象是看不到这个属性的； 
+ 第二，这个属性会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题； 
+ 第三，不能给Person传递参数（让每个stu有自己的属性），因为这个对象是一次性创建的（没办法定制化）；

## 5 借用构造函数继承



## 6 寄生组合实现继承