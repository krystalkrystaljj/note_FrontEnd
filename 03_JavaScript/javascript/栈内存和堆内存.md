程序是要加载到内存中来执行的，我们可以将内存化为两个区域：堆内存和栈内存

+ 原始类型占据的空间是在栈内存中分配的
+ 对象内存占据的空间是在堆内存中分配的



```js
// 现象一：两个对象比较
      var obj1 = {};
      var obj2 = {};
      console.log(obj1 === obj2);
```



![image-20231225204330369](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20231225204330369.png)

只要是对象类型，会在堆内存中重新创建一个对象

对象中赋值赋的是指针，是对应的引用地址



```js
// 现象二：引用的赋值
      var info = {
        name: "why",
        friend: {
          name: "Kobe",
        },
      };

```



![image-20231225205409079](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20231225205409079.png)





```js
// 现象三：值传递
      function foo(a) {
        a = 200
      }
      var num = 100
      foo(num)
      console.log(num);//100
```



```js
// 现象四：引用传递，但是在函数中创建了一个新对象，没有对传入对象进行修改
      function foo(a) {
        a = {
          name:"why"
        }
      }

      var obj = {
        name:"obj"
      }
      foo(obj)
      console.log(obj);
```





```js
// 现象五：引用传递，但是对传入的对象进行修改
      function foo(a) {
        a.name = "tjj"
      }

      var obj = {
        name:"obj"
      }
      foo(obj)
      console.log(obj);
```



# 函数中的this

+ 情况一：如果普通的函数被默认调用，那么this指向的就是window
+ 情况二：如果某个函数是被某个对象来引用并且调用它，那么this将会指向这个对象

```js
	var obj = {
        name:'tjj',
        running:function() {
          console.log(this);
          console.log(obj);
          console.log(this === obj);//从内存的角度来说是指同一块内存
        }
      }
      obj.running()
```



```js
	  var fn = obj.running
      fn()//指向window
```



```js
	  function bar() {
        console.log(this);
      }

      var obj = {
        name:"why",
        bar:bar
      }
      obj.bar()//指向对象obj
```



### 创建对象的方案 – 工厂函数 

+ 可以封装一个函数，这个函数用于帮助我们创建一个对象，我们只需要重复调用这个函数即可；
+ 工厂模式其实是一种常见的设计模式；

```js
	   function createStudent(name,age,height) {
        var stu = new Object()
        stu.name = name
        stu.age = age
        stu.height = height
        stu.running = function () {
          console.log("running");
        }
        return stu
       }

       var stu1 = createStudent('tjj', 18, 1.88)
       var stu2 = createStudent('rl', 18, 1.88)
```



+ 创建一个新对象
+ 将新对象进行返回



构造函数

+ 工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型
  + 但从某些角度来说，这些对象应该有一个他们共同的类型
+ 什么是构造函数
  + 构造函数也称之为构造器（constructor），通常是我们在创建对象时会调用的函数
  + 在其他编程语言中，构造函数是存在于类中的一个方法，称之为构造方法
  + 但是JavaScript中的构造函数有些不一样，构造函数扮演了其他语言中类的角色
+ 也就是在JavaScript中，构造函数就是类的扮演者
  + 比如系统默认提供给我们的Date就是一个构造函数，也可以看成是一个类
  + 在ES5之前，我们都是通过function来声明一个构造函数（类）的，之后通过new关键字对其进行调用
  + 在ES6之后，JavaScript可以像别的语言一样，通过class来声明一个类



类和对象之间的关系



如果一个函数被使用new操作符调用了，那么它会执行如下操作：

+ 1.在内存中创建一个新的对象（空对象）
+ 2.这个对象内部的prototype属性会被赋值为该构造函数的prototype属性
+ 3.构造函数内部的this会指向创建出来的新对象
+ 4.执行函数的内部代码（函数体代码）
+ 5.如果构造函数没有返回非空对象，则返回创建出来的新对象

```js
function student(name,age,height) {
        this.name = name
        this.age = age
        this.height = height
        this.running = function () {
          console.log("running");
        }
       }

       var stu1 = new student('tjj', 18, 1.88)
       var stu2 = new student('rl', 18, 1.88)
```



全局对象window的作用

+ 作用一：查找变量时，最终会找到window头上
+ 作用二：将浏览器全局提供给我们的变量/函数/对象，放在window对象上面
+ 作用三（了解）：使用var定义的变量会被默认创建在window上



函数本身也是一个对象，可以添加属性

```js
	  function sayHello() {}
      sayHello.age = 18;
      console.log(sayHello.age);
```



```js
// 构造函数上（类上面）添加的函数，称之为类方法
      function Dog() {}
      Dog.running = function () {
        console.log("running");
      };
      Dog.running();
```



定义对象类型的变量 地址-指针-引用





