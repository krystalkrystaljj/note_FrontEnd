

路由其实是网络工程中的一个术语： 

+ 在架构一个网络时，非常重要的两个设备就是路由器和交换机。 

+ 事实上，路由器主要维护的是一个映射表； 

+ **映射表**会决定数据的流向； （路由器维护了ip地址和真实电脑mac地址的关系）

路由的概念在软件工程中出现，最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段：

后端路由阶段； 

+ 前后端分离阶段； 
+ 单页面富应用（SPA）





早期的网站开发整个HTML页面是由服务器来渲染的. p 服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示. 

但是, 一个网站, 这么多页面服务器如何处理呢? p 一个页面有自己对应的网址, 也就是URL； p URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理； p Controller进行各种处理, 最终生成HTML或者数据, 返回给前端. 

上面的这种操作, 就是后端路由： p 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端. p 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化. 

后端路由的缺点: p 一种情况是整个页面的模块由后端人员来编写和维护的； p 另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码； p 而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情；





前端渲染的理解： 

+ 每次请求涉及到的静态资源都会从静态资源服务器获取，这些资源包括HTML+CSS+JS，然后在前端对这些请 求回来的资源进行渲染； 
+ 需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件； 
+ 同时可以看到，和之前的后端路由不同，这时后端只是负责提供API了； 

前后端分离阶段： 

+ 随着Ajax的出现, 有了前后端分离的开发模式； 
+ 后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中； 
+ 这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上； 
+ 并且当移动端(iOS/Android)出现后，后端不需要进行任何处理，依然使用之前的一套API即可； 
+ 目前比较少的网站采用这种模式开发（jQuery开发模式）





前端路由是如何做到URL和内容进行映射呢？监听URL的改变。 

URL的hash 

+ URL的hash也就是锚点(#), 本质上是改变window.location的href属性； 

+ 我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新； 

hash的优势就是兼容性更好，在老版IE中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径

```html
  <div id="app">
    <a href="#/home">home</a>
    <a href="#/about">about</a>

    <div class="content">
      Default
    </div>
  </div>
```



```js
    const contentEl = document.querySelector('.content')
    window.addEventListener("hashchange",()=>{
      switch (location.hash) {
        case "#/home":
          contentEl.innerHTML = "home"
          break;
        case "#/about":
          contentEl.innerHTML = "about"
          break;
        default:
          contentEl.innerHTML = "Default"
      }
    })
```





history接口是HTML5新增的, 它有l六种模式改变URL而不刷新页面： 

+ replaceState：替换原来的路径； 
+ pushState：使用新的路径； 
+ popState：路径的回退； 
+ go：向前或向后改变路径； 
+ forward：向前改变路径； 
+ back：向后改变路径；

![image-20230711093156101](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230711093156101.png)



![image-20230711100841356](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230711100841356.png)





![image-20230711102659415](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230711102659415.png)

> history.pushState({},"",href)// 压栈操作，可以返回
>
> history.replaceState({},"",href)//替换操作，没有返回





使用vue-router的步骤: 

+ 第一步：创建路由组件的组件； 
+ 第二步：配置路由映射: 组件和路径映射关系的routes数组； 
+ 第三步：通过createRouter创建路由对象，并且传入routes和history模式； 
+ 第四步：使用路由: 通过



![image-20230711110650450](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230711110650450.png)

![image-20230711110923170](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230711110923170.png)

+ 目前前端流行的三大框架, 都有自己的路由实现: 

  + Angular的ngRouter 

  + React的ReactRouter 

  + Vue的vue-router 

+  Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得非常容易。 
  + 目前Vue路由最新的版本是4.x版本，我们上课会基于最新的版本讲解。 
+ vue-router是基于路由和组件的 
  + 路由用于设定访问路径, 将路径和组件映射起来. 
  + 在vue-router的单页面应用中, 页面的路径的改变就是组件的切换. 
+ 安装Vue Router：  

```
npm install vue-router@4
```





![image-20230712093223955](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712093223955.png)

![image-20230712094258039](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712094258039.png)

+ 我们这里还有一个不太好的实现: 
  + 默认情况下, 进入网站的首页, 我们希望渲染首页的内容； 
  + 但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以；

+  如何可以让路径默认跳到到首页, 并且渲染首页组件呢? 

+ 我们在routes中又配置了一个映射： 
  + path配置的是根路径: / predirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了.

```js
// 配置映射关系
const routes = [
  {path:'/',redirect:"/home"},
  {path:'/home',component:Home},
  {path:'/about',component:About}
]
```





router-link事实上有很多属性可以配置： 

to属性： p是一个字符串，或者是一个对象 

replace属性： p设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()； 

active-class属性： p设置激活a元素后应用的class，默认是router-link-active n exact-active-class属性： p链接精准激活时，应用于渲染的  的 class，默认是router-link-exact-active





![image-20230712102633714](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712102633714.png)

![image-20230712105442169](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712105442169.png)





+ 路由的其他属性
+ ![image-20230712110431999](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712110431999.png)



+ 路由的路径可以不写死，可以给一个占位的默认值，到时候传给一个具体值 通过$route去获取这个值
+ useRoute返回当前点击的页面的route



![image-20230712151636518](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712151636518.png)

+ 如果不填写动态字段的参数，则无法匹配路由



![image-20230712151657147](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712151657147.png)





![image-20230712152309946](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712152309946.png)



+ 匹配多个参数

![image-20230712152514044](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712152514044.png)

| 匹配模式  | 匹配路径  | $route.parmas |
| --------- | --------- | ------------- |
| /user/:id | /user/123 | {id:'123}     |



+ 我们可以通过 $route.params.pathMatch获取到传入的参数：

![image-20230712162802727](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230712162802727.png)



什么是路由的嵌套呢？ 

目前我们匹配的Home、About、User等都属于底层路由，我们在它们之间可以来回进行切换； 

但是呢，我们Home页面本身，也可能会在多个组件之间来回切换： 

+ 比如Home中包括Product、Message，它们可以在Home内部来回切换； 

这个时候我们就需要使用嵌套路由，在Home中也使用 router-view 来占位之后需要渲染的组件；



有时候我们希望通过代码来完成页面的跳转，比如点击的是一个按钮： 

当然，我们也可以传入一个对象： 

如果是在setup中编写的代码，那么我们可以通过 useRouter 来获取





### 代码的页面跳转

+ 编程式路由跳转
+ 如何获取router
  + 一种是通过`this.$router`
  + 第二种是通过userRouter()的一个hook

+ 给button添加一个点击事件

![image-20230713150944520](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230713150944520.png)





![image-20230713152806767](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230713152806767.png)



#### router-link中的v-slot

