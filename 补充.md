### 函数的重载

#### 联合类型



```ts
/**
 * 通过联合类型有两个缺点:
 *  1.进行很多的逻辑判断(类型缩小)
 *  2.返回值的类型依然是不能确定
 */
function add(a1:number | string, a2:number|string) {
  if(typeof a1 === "number" && typeof a2 === "number") {
    return a1 + a2
  } else if(typeof a1 === "string" && typeof a2 === "string") {
    return a1 + a2
  }
}

console.log(add(10,20));
console.log(add('why',"tjj"));
```



### 函数的重载

```ts
// 函数的重载: 函数的名称相同, 但是参数不同的几个函数, 就是函数的重载
function add(num1:number,num2:number):number;
function add(num1:string,num2:string):string

function add(num1:any, num2:any): any {
  if(typeof num1 === "string") {
    return num1.length + num2.length
  }
  return num1+num2
}

const result = add(20,30)
const result2 = add('tjj','why')
console.log(result);
console.log(result2);

// 在函数的重载中, 实现函数是不能直接被调用的
// add({name: "why"}, {age: 18})


export{}
```



函数重载案例

```ts
// 返回字符串或数组的长度
// 实现方式一：联合类型
function getLength(args:string | any[]) {
  return args.length
}
console.log(getLength("abc"));
console.log(getLength([123,456,555,4]));

// 实现方式二：函数的重载
function getLength(args: string): number
function getLength(args: any[]): number

function getLength(args: any): number {
  return args.length
}

console.log(getLength("abc"))
console.log(getLength([123, 321, 123]))
```





## 类的使用

### 类的定义

```ts
class Person {
  name:string
  age: number

  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }

  eating() {
    console.log(this.name + "eating");
    
  }
}

const p = new Person("tjj",13)
console.log(p.name);
p.eating()
```



### 类的继承

```ts
class Person {
  name:string = 'tjj'
  age:number = 0

  eating() {
    console.log('eating');
  }
}

class Student extends Person {
  sno: number = 123

  studying() {
    console.log("studying");
  }
}

class Teacher extends Person {
  title:string = ''
  teaching() {
    console.log('teaching');
    
  }
}

const stu = new Student()
stu.name='why'
console.log(stu.name);
stu.eating()
```



+ 在创建的时候进行初始化,子类如何继承父类的构造器函数

```ts
class Person {
  name:string
  age:number

  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }

  eating() {
    console.log('eating');
  }
}

class Student extends Person {
  sno: number

  constructor(name:string, age: number, sno: number) {
    // super调用父类的构造器
    super(name,age)
    this.sno = sno
  }

  studying() {
    console.log("studying");
  }
}

const stu = new Student("why", 18, 111)
console.log(stu.name);
console.log(stu.age);
console.log(stu.sno);
stu.eating()
```



### 多态

+ 多态中一定有继承或接口
+ 多态的目的是为了写出更加具备通用性的代码

```ts
class Animal {
  action() {
    console.log("animal action");
    
  }
}

class Dog extends Animal {
  action() {
    console.log("dog running");
  }
}

class Fish extends Animal {
  action() {
    console.log("Fish swimming");
  }
}

class Bird extends Animal {
  action() {
    console.log("dog flying");
  }
}

// 传入的参数是数组类型，每个元素是一个Animal类型
function makeAction(animals: Animal[]) {
  animals.forEach(animal => {
    animal.action()
  })
}

makeAction([new Dog(), new Fish(), new Bird()])
```



### 成员修饰符

```TS
class Person {
  private name: string = "0"

  getName() {
    return this.name
  }
  setName(newName: string) {
    this.name = newName
  }

}

const p = new Person()
p.setName('tjj')
console.log(p.getName());
```



+ 子类可以访问父类中的protect属性

```ts
class Person {
  protected name: string = "123"
}

class Student extends Person {
  getName() {
    return this.name
  }
}

const stu = new Student()
console.log(stu.getName());
```



### readonly属性

```ts
class Person {
  // 1.只读属性可以在构造器中赋值，赋值之后就不能再修改
  // 2.属性本身不能进行修改，但是如果它是对象类型，对象中的属性是可以修改（类似于const）
  readonly name: string
  readonly friend?: Person
  age?: number
  constructor(name:string, friend?: Person) {
    this.name = name 
    this.friend = friend
  }
}


const p = new Person("why",new Person("kobe"))
console.log(p.name);
console.log(p.friend);

// 属性本身不能进行修改，但是如果它是对象类型，对象中的属性是可以修改（类似于const）
if(p.friend) {
  p.friend.age = 30
}
console.log(p.friend);

```



### getter/setter

+ 从ES5开发，提供了`getter`和`setter` 可以将属性值的获取和设置分别绑定到方法上，称之为“存取器”。有了getter和setter我们就能够在属性值的变更和获取时实现一些操作。

```ts
class Person {
  // 私有成员变量一般以_开头
  private _name:string
  constructor(name: string) {
    this._name = name
  }

  // 访问器setter/getter
  set name(newName) {
    this._name = newName
  }

  get name() {
    return this._name
  }
}

const p = new Person("why")
p.name = "coderwhy"
console.log(p.name)
```





### 静态成员

+ 静态成员属性可以通过类名去访问
+ 静态成员方法也可以通过类名直接访问

```ts
class Student {
  static time: string = "20:00"

  static attendClass() {
    console.log("去学习");
  }
}

console.log(Student.time);
Student.attendClass()
```





### 抽象类

+ 抽象函数可以没有实现体
+ 抽象方法必须存在于抽象方法中
+ 抽象类不能被实例化

+ 将函数写成抽象方法的目的在于防止new一个对象传入，实例化一个对象，传入参数
+ new Shape传进来，但shape类中的getArea()方法没有实现

```ts
// 计算传入的图形，计算面积
// 要具备通用性，根据传入图形的不同，计算面积
// shape类型必须图形一类，不能是any
function makeArea(shape: Shape) {
  return shape.getArea()
}

// 为了防止makeArea(new Shape())情况的发生
// 这里的父类应该是一个抽象类，不进行具体实现,而抽象类是不能进行实例化的
// 抽象函数可以没有实现体
abstract class Shape {
  abstract getArea(): number
}


class Rectangle extends Shape {
  private width: number
  private height: number

  constructor(width: number, height: number) {
    // 初始化父类中的属性，即使父类中没有属性
    super()
    this.width = width
    this.height = height
  }

  getArea() {
    return this.width * this.height
  }
}

class Circle extends Shape {
  private r: number
  constructor(r: number) {
    // 初始化父类中的属性
    super()
    this.r = r
  }

  getArea() {
    return this.r * this.r * 3.14
  }
}

const rectangele = new Rectangle(20, 30)
const circle = new Circle(10)

console.log(makeArea(rectangele));
console.log(makeArea(circle));
```



### 类的类型

```ts
class Person {
  name: string = "123"
  eating() {

  }
}

// 可以不进行初始化对象，而是写成类的类型
const p: Person = {
  name:'tjj',
  eating() {

  }
}
```



+ 应用场景

```ts
function printPerson(p: Person) {
  console.log(p.name);
}

printPerson(new Person())
printPerson({name:'tjj', eating: function() {}})
```

