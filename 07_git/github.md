集中式版本控制（Centralized Version Control System，简称CVCS）

+ 它们的主要特点式单一的**集中管理的服务器，保存所有文件的修订版本**
+ 协同开发人员通过客户端**连接到这台服务器，取出最新的文件或者提交更新**



核心问题：**中央服务器不能出故障**

+ 如果宕机一小时，那么在这一小时之内谁也无法提交更新
+ 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，那么会丢失所有数据





分布式版本控制

git是属于分布式版本控制系统（Distributed Version Control System，简称DVCS）

+ 客户端并不只是提取最新版本的文件快照，而是**把代码仓库完整的镜像下来，包括完整的历史纪录**
+ 任何一处协同工作用的**服务器发生故障**，事后都**可以用任何一个镜像出来的本地仓库恢复**
+ 因为每一次的克隆操作，都是**对代码仓库的完整备份**



集中式就是将我们的仓库都放在服务器上面，而分布式则是每台电脑上都有一个仓库，可以在本地提交，将本地的仓库同步到远程服务器上



Bash – CMD – GUI 区别

Bash，Unix shell的一种，Linux与Mac OS X都将它作为默认shell

+ Git Bash就是一个shell，是**Windows下的命令工具**，可以**执行Linux命令**
+ Git Bash是基于CMD的，在CMD的基础上增添一些新的命令与功能

Git CMD 

+ 命令行提示符（CMD）是 Windows 操作系统上的命令行解释程序； 
+ 当你在 Windows 上安装 git 并且习惯使用命令行时，可以使用 cmd 来运行 git 命令；

 Git GUI 

+ 基本上针对那些不喜欢黑屏（即命令行）编码的人； 
+ 它提供了一个图形用户界面来运行 git 命令； 



Git的配置分类





### 获取Git仓库 – git init/git clone

+ 通过git来管理源代码，那么本地也需要有一个Git仓库

通常有两种获取Git仓库的方式

+ 初始化一个Git仓库，并且将当前的项目文件添加到Git仓库中（目前很多的脚手架在创建项目时都会默认创建一个Git仓库）
+ 从其他服务器克隆（clone）一个已经存在的Git仓库

方式一：初始化git仓库

+ 该命令将创建一个名为.git的子目录，这个子目录含有初始化的GIt仓库中所有的必须文件，这些文件是Git仓库的核心
+ 这时仅仅做了一个初始化的操作，仓库中的文件还没有被跟踪

```
git init
```

方式二：从远程仓库克隆

```
git clone ....
```





### 文件的状态划分

现在我们的电脑上已经有一个Git仓库： 

+ 在实际开发中，你需要将某些文件交由这个Git仓库来管理； 
+ 并且我们之后会修改文件的内容，当达成某一个目标时，想要记录下来这次操作，就会将它提交到仓库中； 

那么我们需要对文件来划分不同的状态，以确定这个文件是否已经归于Git仓库的管理： 

+ **未跟踪**：默认情况下，Git仓库下的文件也没有添加到Git仓库管理中，我们需要通过add命令来操作； 
+ **已跟踪**：添加到Git仓库管理的文件处于已跟踪状态，Git可以对其进行各种跟踪管理；(通过以下命令可将未跟踪的文件变为已跟踪)

```
git add .
```



已跟踪的文件又可以进行细分状态划分：

+ **staged**：缓存区中的文件状态
+ **unmodified**：commit命令，可以将staged中文件提交到Git仓库
+ **Modified**：修改了某个文件后，会处于Modified状态

![image-20231114170957070](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20231114170957070.png)





### 检测文件的状态 - git status

Untracked files：未跟踪的文件 

+ 未跟踪的文件意味着 Git 在之前的提交中没有这些文件； 
+ Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”；