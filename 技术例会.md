# 标题1 理论体系背景

（说明讲解的技术是什么，用来解决什么问题，以及它的定义和相关基础知识、术语都要进行叙述，小标题自拟）

1. 问题域（使用上的表象）
2. 术语体系
3. 所属的计算机学科核心问题模型

https://web.dev/howbrowserswork/

## 引言

+ 写出更好的代码和提供更好的用户体验
+ 虽然浏览器浏览器品类众多，但他们提供的功能也都基本类似，框架结构也都大同小异



+ 用户界面：用来展示除镖旗那也窗口一味的其他用户界面内容
+ 浏览器引擎：数据持久层，帮助浏览器存储各种数据，例如cookie等等
+ **渲染引擎**（浏览器的核心，称为内核）：下有许多小的模块（浏览器内核负责渲染网页，并在渲染过程中执行JavaScript代码。）
  + 负责网卡请求的网络模块
  + Js解析器



> 浏览器其实是运行在浏览器上的一个应用程序，每个程序往往需要运行很多任务，进程就会创建一些线程来帮助它去执行这些小任务
>
> + 进程是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体
>
> + 线程是操作系统能够进行运算调度的基本单位，一个进程可以并发多个线程，每条线程并行执行不同的任务
>
> + 进程间传递数据是通过IPC来传递



## 发展

早期的浏览器是一个单进程结构，一个进程中大概有页面线程负责页面、渲染和展示等，js线程执行js代码，还有其他各种线程

单进程的结构引发了很多问题，

1. 其中一个线程的卡死可能会导致整个进程出问题，比如打开多个标签页，其中一个标签卡死可能会导致整个浏览器无法运行
2. 不安全，浏览器之间是可以共享数据的，那么js线程岂不是可以随意访问浏览器进程内的所有数据
3. 不流畅，需要负责太多事情，会导致运行效率的问题



为了解决以上问题，现在采用多进程浏览器结构，根据进程功能不同来拆卸浏览器

+ **浏览器进程**负责Chrome浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进的按钮，以及负责与浏览器的其他进程协调工作
+ **网络进程**负责发起接受网络请求
+ **GPU进程**负责整个浏览器界面的渲染
+ **插件进程**负责控制网站使用的所有插件，例如flash，这里的插件并不是指Chrome商城里安装的扩展
+ **渲染器进程**用来控制显示Tab标签内的所有内容

浏览器在默认情况下会为每个标签页都创建一个进程

> 这个和你选择的Chrome进程模型有关，Chrome官方文档上说明了Chrome一共有4种进程模型
>
> ....模型会创建更多的进程，占用更多的内存空间，但确实是最安全的，每个Tab以及Tab内的每个站点都是相互隔离互不影响的，当其中一个标签页渲染器进程卡死，并不会影响其他标签



+ 当在浏览器的地址局域栏输入地址时，浏览器的UI线程会捕捉你输入的内容，如果访问的是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器获取数据，

+ 如果你的输入不是网址而是一串关键词，浏览器就知道你是要搜索，于是就会使用默认配置的搜索引擎来查询



网络线程获取到数据之后会发生什么？

1. 当网络线程获取到数据之后会通过safeBrowsing来检查站点是否是恶意站点，如果是，则会提示个警告页面，告诉你这个站点有安全问题，浏览器会阻止你的访问，当然你也可以强行继续访问，

> safeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如通过查看该站点的IP是否在谷歌的黑名单之内，

2. 当返回数据准备完毕，并且安全校验通过时，网络线程会通知UI线程，UI线程会创建一个渲染器进程（Renderer Thread）来渲染页面，浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程，
3. 渲染器进程接收到的数据也就是html渲染器进程的核心任务就是把html、css、js、image等资源渲染成用户可以交互的web页面，渲染器进程的主线程将html进行解析构造DOM数据结构

> DOM就是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过js与之交互的数据结构和API

+ html首先经过tokeniser标记化，通过此法分析将输入的html内容解析成多个标记更加识别后的标记进行DOM树构造，
+ 在DOM树构造过程中会创建Document对象，然后以Document的为根节点的DOM树不断进行修改，向其中添加各种元素，html代码中往往会引入一些额外的资源，比如图片、css、js脚本等，图片和css这些资源需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞HTML的解析，因为他们不会影响DOM的生成，但是当HTML标解析过程中原道script标签，就会停止HTMl解析流程，转而去加载解析并且执行js（因为浏览器并不知道js执行是否会改变当前页面的HTML结构，如果js中调用了document.write方法来修改HTML，那之前的HTML解析就没有意义了）



DOM树生成后我们并不知道DOMTree上每个节点应该长什么样子，主线程需要解析css，并确定每个DOM节点的计算样式，即使你没有提供自定义的css样式，浏览器会有自己默认的样式表

主线程遍历LayoutTree，创建一个绘制记录表（Paint Record），该表记录了绘制的顺序

将这些信息转化为像素点显示在屏幕上，这种行为称为栅格化（Rastering），Chrome最早使用了一种很简单的方式，只栅格化用户可视区域（Viwport）的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式会导致展示延迟，

随着不断优化升级现在的Chrome使用一种更为复杂的栅格化流程，叫做合成（Composting），合成是一种将页面的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程（CompositorThread）的技术中单独进行合成页面，即页面中的所有元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可，主线程遍历LayoutTree，生成Layer Tree，当Layer Tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程将每个图层进行栅格化



网页的解析过程

浏览器渲染流程

回流和重绘解析



合成和性能优化

defer和async属性



## 网页的整体解析流程

### 1.1 网页被下载的过程

1. **下载 HTML 文件** 当用户在浏览器中输入网址时，浏览器会向服务器发送请求，请求下载网站的 HTML 文件。
2. 解析HTML文件  下载完成后，浏览器开始解析HTML文件，并构建DOM树。在解析过程中如果遇到外部链接的css和javascript文件，浏览器会发起新的请求来下载这些文件
3. 下载css文件 当浏览器遇到link元素时，会发起新的请求来下载该元素的href属性指向的css文件。下载完成后，浏览器会将css文件解析成CSSDOM树，并将其与DOM树合并，构建出渲染树。
4. 下载JavaScript文件 当浏览器遇到script元素时，会发起新的请求来下载该元素的scr属性指向的JavaScript文件。下载完成之后，浏览器会解析JavaScript代码，并执行其中的命令。在执行过程中如果代码需要操作DOM和CSSDOM树，浏览器会进行相应的操作。



### 1.2 浏览器内核的理解

浏览器解析网页的过程通常是由浏览器内核完成的

+ 浏览器内核是指浏览器中负责解析HTML、CSS JavaScript等文件的核心组成，也被称为渲染引擎

当用户在浏览器中输入网址时，浏览器内核会根据协议类型（如HTTP或HTTPS）向服务器发送请求，下载网站的HTML文件

+ 在下载完成之后，浏览器内核会开始解析HTML文件，构建DOM树，根据DOM树和CSS样式表构建渲染树，最终将页面呈现给用户



我们经常说的浏览器内核指的是浏览器的排版引擎：排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）或样版引擎。



### 1.3 页面渲染整体流程

渲染引擎在拿到一个页面后，如何解析整个页面并且最终呈现出我们的网页呢？

![image-20230925154624141](https://raw.githubusercontent.com/krystalkrystaljj/myimg/main/image-20230925154624141.png)

​																					整体流程图

![](https://web-dev.imgix.net/image/T4FyVKpzu4WKF1kBNvXepbi08t52/S9TJhnMX1cu1vrYuQRqM.png?auto=format&w=741)

​																					详细流程图

1. 解析HTML文件，构建DOM树
2. 解析CSS文件，构建CSSOM树
3. 将DOM树和CSSOM树合并成渲染树
4. 生成布局树，计算每个元素在页面上的位置和大小
5. 绘制渲染树，将渲染树绘制成屏幕上的像素
6. 合成层，将多个图层合并成一个图层，以便使用GPU进行加速
7. 使用GPU加速，对图层进行合成，形成最终的图像
8. 如果发送重绘或回流操作，重新执行步骤4-7

有些操作会触发重绘或回流，如改变元素的位置、大小、颜色等。这些操作会影响页面的性能和渲染速度，因此需要尽可能避免。



## 二 页面的详细解析流程

### 2.1 HTML的解析过程

HTML解析过程，构建DOM树，是浏览器渲染的第一步

- 因为默认情况下服务器会给浏览器返回index.html文件，所以解析HTML是所有步骤的开始：



1. **获取 HTML 文件** 当用户在浏览器中输入网址时，浏览器会向服务器发送请求，请求下载网站的 HTML 文件。
2. **HTML 标记识别** 浏览器会将 HTML 文件解析成一个个标记（tag），如 div、p、img 等等。解析的过程中，浏览器会忽略一些不合法的标记，如没有闭合标签、属性值没有使用引号等等。
3. **DOM 树构建** 浏览器会将解析后的标记转化成一个个 DOM 节点（Node），构建成一棵 DOM 树（Document Object Model）。DOM 树是一个树形结构，根节点是 document，其他节点代表 HTML 文档中的元素、属性、文本等等。

在构建 DOM 树的过程中，浏览器会按照 HTML 文档的层次结构，将文档分成一个个的块（block），如文本块、段落块、表格块等等。每个块都会被转换成一个 DOM 节点，节点之间的关系由 HTML 标记之间的关系来确定。



### 2.2. 解析生成CSS规则

生成 CSS 规则，是浏览器解析 HTML 文件的一部分。

- 在解析 HTML 文件的过程中，如果遇到 CSS 的 link 元素，浏览器会下载对应的 CSS 文件。
- 需要注意的是，下载 CSS 文件不会影响 DOM 的解析。

下载完成后，浏览器会对 CSS 文件进行解析，解析出对应的规则树。

- 这个树形结构称为 CSSOM（CSS Object Model，CSS 对象模型），它描述了 HTML 文档中各元素的样式和布局信息。

在CSSOM中，每个节点代表一个CSS规则，包括选择器和声明

+ 选择器指定了那些元素会被应用这个规则，声明则制定了这些元素的样式属性和值
+ CSSOM树的构建过程类似于DOM树的构建过程，也是一个逐步解析的过程



### 2.3 构建RenderTree

当有了DOM Tree和CSSOM Tree后，就可以两个结合构建RenderTree了

注意事项：

注意一：

+ 需要注意的是，link元素不会阻塞DOM树的构建过程，但会阻塞Render Tree的构建过程
+ 这是因为Render Tree在构建时需要对应的CSSOM Tree

注意二：

+ 同时，需要注意的是Render Tree和DOM Tree并不是一一对应的关系
+ 例如，对于display为none的元素，它不会在Render Tree中出现。这是因为该元素被隐藏了，不会影响页面的呈现，因此也不需要在渲染树中进行渲染

### 2.4. 布局和绘制的过程

步骤4布局的过程

+ 在步骤4中，浏览器会在渲染树（Render Tree）上运行布局（Layout）以计算每个节点的几何体
+ 渲染树表示显示哪些节点以及其他样式，但不表示每个节点的尺寸、位置等信息。布局时确定呈现树中所有节点的宽度、高度和位置信息

步骤4绘制的过程：

+ 在第五步中，浏览器将每个节点绘制到（Paint）屏幕上
+ 在绘制阶段，浏览器将布局阶段计算的每个frame转换为屏幕上的像素点
+ 这个部分包括将元素可见的部分进行绘制，例如文本、颜色、边框、阴影、替换元素（例如img）等等

### 2.5. 回流和重绘的问题

这里还有两个比较重要的概念，也是会对浏览器渲染过程中引发性能问题的两个重要概念：**回流和重绘**。

#### 2.5.1. 回流的解析

理解回流reflow：（也可以称之为重排）

+ 第一次确定节点的大小和位置，称之为布局（layout）
+ 之后对节点的大小、位置修改重新计算称之为回流。

也就是说回流是指浏览器必须 重新计算渲染树中部分或全部元素的集合信息（位置和大小）

触发回流的情况有很多，常见的包括：

1. DOM结构的变化，比如添加、删除、移动元素等操作
2. 改变元素的布局，比如修改元素的宽高、padding、margin、border、position、display 等属性；
3. 页面尺寸的变化，比如浏览器窗口大小的变化，或者文档视口的变化
4. 获取元素的集合属性比如调用 getComputedStyle() 方法获取元素的尺寸、位置等信息

回流的代价比较高，因为它会涉及到大量的计算和页面重排，这会导致页面的性能和响应速度下降。



#### 2.5.2. 重绘的解析

理解重绘repaint：

+ 第一次渲染内容称为绘制（paint）
+ 之后重新渲染称之为重绘

重绘是指浏览器不需要重新计算元素的几何信息，而只需要重新绘制元素的内容的过程。

触发重绘的情况有很多，常见的包括：

1. 修改元素的颜色、背景色、边框颜色、文本样式等属性；
2. 修改元素的 box-shadow、text-shadow、outline 等属性；
3. 使用 CSS3 transform 和 opacity 等属性；
4. 添加、移除、修改元素的 class；
5. 使用 JavaScript 直接修改样式。

重绘的代价比较小，因为它不涉及到元素的位置和大小等计算，只需要重新绘制元素的内容即可。



**回流一定会引起重绘，所以回流是一件很消耗性能的事情。**



#### 2.5.3. 页面性能优化

避免回流是提高页面性能的重要手段之一，以下是一些常用的优化方法：

1. 尽量一次性修改样式 可以使用 cssText 属性、添加 class 等方式，一次性修改元素的样式，避免多次修改引起页面的回流。比如，可以将需要修改的样式保存在一个对象中，然后一次性设置给元素，避免多次触发回流。
2. 避免频繁的操作 DOM 可以使用 DocumentFragment 或者父元素来操作 DOM，避免频繁地操作 DOM 元素，从而减少页面的回流次数。
3. 避免使用 getComputedStyle() 获取元素信息 因为 getComputedStyle() 方法会强制浏览器进行回流操作，从而影响页面的性能。如果需要获取元素的信息，可以在修改样式之前先保存到变量中，避免多次触发回流。
4. 使用 position:absolute 或者 position:fixed 属性 使用 position:absolute 或者 position:fixed 属性可以将元素从文档流中脱离出来，从而避免影响其他元素的位置和大小。虽然这也会引起回流，但是相对于修改文档流中的元素来说，开销较小，对页面的性能影响较小。

总之，避免回流是一项重要的优化技巧，可以帮助我们提高页面的性能和响应速度。可以采用一些常用的优化方法，减少回流的次数，从而提高页面的渲染速度和性能。



### 2.6. **composite**合成

绘制的过程，可以将布局后的元素绘制到多个合成图层中。

- 这是浏览器的一种优化手段；

默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的；

而一些特殊的属性，会创建一个新的合成层（ CompositingLayer ），并且新的图层可以利用GPU来加速绘制；

- 因为每个合成层都是单独渲染的；

![图片](https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXutNeJicXEbsibyqDEicPU8UduYstUeBLRe5eTYTqQuxvTq9O8gXBuVAHZnxXic0jKiaGJAb1mqtU92jEKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)合成层的效果

有些属性可以触发合成层的创建，包括：

1. 3D 变换（3D Transforms）：如 rotateX、rotateY、translateZ 等属性，可以创建一个新的合成层。
2. video、canvas、iframe 等标签：这些标签会创建一个新的合成层。
3. opacity 动画转换时：当元素透明度发生变化时，会创建一个新的合成层。
4. position: fixed：将元素定位为固定位置时，也会创建一个新的合成层。
5. will-change 属性：可以通过这个实验性的属性，告诉浏览器元素可能会发生哪些变化，从而预先创建合成层。
6. 动画（Animation）或过渡（Transition）设置了 opacity、transform 属性时，也会创建一个新的合成层。

需要注意的是，过度使用合成层也会带来一些问题，如占用更多的内存、增加页面的复杂度等。

- 因此，在使用合成层时需要谨慎，避免滥用。

# 标题2 应用场景

（针对不同的问题场景，说明技术的实际应用，**要亲自做实验验证**，小标题自拟）

1. 总结出几个适用场景
2. 总结出几个不适用场景
3. 泛化总结
   - 必须使用这种技术吗
   - 使用这种技术，优势，副作用
   - 不使用这种技术，问题
   - 如果要改进，改进的思路
4. 思考把这项技术部署到项目中的必要性，可行性，如何实现



# 标题3 其他相关技术体系

（对比其他相关技术，说明优势在哪，以及各自适合的应用场景，并做实验进行验证，小标题自拟）

1. 其他名字不同，本质相同的技术



# 标题4 在EC项目/Jetlinks上的应用

（说明联系，小标题自拟）
参考网站：http://doc.jetlinks.cn/



# 标题5 总结与展望

（对本次技术分享进行一个总结，要有自己的见解，并展望未来的发展方向，小标题自拟）



# 标题6 参考文献

（注明是内部文献还是外部文献，内部文献是以往学长学姐或同学们已经讲过的内容，外部文献是上网搜索的文献，包括参考的视频、博客等来源。）



https://juejin.cn/post/6982531924023754783

https://developer.aliyun.com/article/1284630

https://vue3js.cn/interview/css/layout_painting.html#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91

https://juejin.cn/post/6850418121548365831